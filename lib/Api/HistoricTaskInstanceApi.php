<?php
/**
 * HistoricTaskInstanceApi
 * PHP version 5
 *
 * @category Class
 * @package  Camunda\Client
 * @author   Nik54rus
 * @link     https://github.com/nik54rus/camunda-open-api
 */

/**
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.21.1-ee
 * 
 * Generated by: https://github.com/nik54rus/camunda-open-api.git
 * Camunda Codegen version: 3.0.56
 */


namespace Camunda\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Camunda\Client\ApiException;
use Camunda\Client\Configuration;
use Camunda\Client\HeaderSelector;
use Camunda\Client\ObjectSerializer;

/**
 * HistoricTaskInstanceApi Class Doc Comment
 *
 * @category Class
 * @package  Camunda\Client
 * @author   Nik54rus
 * @link     https://github.com/nik54rus/camunda-open-api
 */
class HistoricTaskInstanceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getHistoricTaskInstanceReport
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\HistoricTaskInstanceReportResultDto[]
     */
    public function getHistoricTaskInstanceReport($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        list($response) = $this->getHistoricTaskInstanceReportWithHttpInfo($report_type, $period_unit, $completed_before, $completed_after, $group_by);
        return $response;
    }

    /**
     * Operation getHistoricTaskInstanceReportWithHttpInfo
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\HistoricTaskInstanceReportResultDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricTaskInstanceReportWithHttpInfo($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        $returnType = '\Camunda\Client\Model\HistoricTaskInstanceReportResultDto[]';
        $request = $this->getHistoricTaskInstanceReportRequest($report_type, $period_unit, $completed_before, $completed_after, $group_by);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\HistoricTaskInstanceReportResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricTaskInstanceReportAsync
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstanceReportAsync($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        return $this->getHistoricTaskInstanceReportAsyncWithHttpInfo($report_type, $period_unit, $completed_before, $completed_after, $group_by)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricTaskInstanceReportAsyncWithHttpInfo
     *
     * Get Task Report (Historic)
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstanceReportAsyncWithHttpInfo($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {
        $returnType = '\Camunda\Client\Model\HistoricTaskInstanceReportResultDto[]';
        $request = $this->getHistoricTaskInstanceReportRequest($report_type, $period_unit, $completed_before, $completed_after, $group_by);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricTaskInstanceReport'
     *
     * @param  string $report_type **Mandatory.** Specifies the kind of the report to execute. To retrieve a report about the duration of process instances the value must be set to &#x60;duration&#x60;. For a report of the completed tasks in a specific timespan the value must be set to &#x60;count&#x60;. (optional)
     * @param  string $period_unit When the report type is set to &#x60;duration&#x60;, this parameter is **mandatory**. Specifies the granularity of the report. Valid values are &#x60;month&#x60; and &#x60;quarter&#x60;. (optional)
     * @param  \DateTime $completed_before Restrict to tasks that were completed before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $completed_after Restrict to tasks that were completed after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $group_by When the report type is set to &#x60;count&#x60;, this parameter is **mandatory**. Groups the tasks report by a given criterion. Valid values are &#x60;taskName&#x60; and &#x60;processDefinition&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricTaskInstanceReportRequest($report_type = null, $period_unit = null, $completed_before = null, $completed_after = null, $group_by = null)
    {

        $resourcePath = '/history/task/report';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($report_type !== null) {
            $queryParams['reportType'] = ObjectSerializer::toQueryValue($report_type, null);
        }
        // query params
        if ($period_unit !== null) {
            $queryParams['periodUnit'] = ObjectSerializer::toQueryValue($period_unit, null);
        }
        // query params
        if ($completed_before !== null) {
            $queryParams['completedBefore'] = ObjectSerializer::toQueryValue($completed_before, 'date-time');
        }
        // query params
        if ($completed_after !== null) {
            $queryParams['completedAfter'] = ObjectSerializer::toQueryValue($completed_after, 'date-time');
        }
        // query params
        if ($group_by !== null) {
            $queryParams['groupBy'] = ObjectSerializer::toQueryValue($group_by, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricTaskInstances
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\HistoricTaskInstanceDto[]
     */
    public function getHistoricTaskInstances($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->getHistoricTaskInstancesWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation getHistoricTaskInstancesWithHttpInfo
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\HistoricTaskInstanceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricTaskInstancesWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Camunda\Client\Model\HistoricTaskInstanceDto[]';
        $request = $this->getHistoricTaskInstancesRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\HistoricTaskInstanceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricTaskInstancesAsync
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesAsync($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        return $this->getHistoricTaskInstancesAsyncWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricTaskInstancesAsyncWithHttpInfo
     *
     * Get Tasks (Historic)
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesAsyncWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Camunda\Client\Model\HistoricTaskInstanceDto[]';
        $request = $this->getHistoricTaskInstancesRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups, $sort_by, $sort_order, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricTaskInstances'
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricTaskInstancesRequest($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/history/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_id !== null) {
            $queryParams['taskId'] = ObjectSerializer::toQueryValue($task_id, null);
        }
        // query params
        if ($task_parent_task_id !== null) {
            $queryParams['taskParentTaskId'] = ObjectSerializer::toQueryValue($task_parent_task_id, null);
        }
        // query params
        if ($process_instance_id !== null) {
            $queryParams['processInstanceId'] = ObjectSerializer::toQueryValue($process_instance_id, null);
        }
        // query params
        if ($process_instance_business_key !== null) {
            $queryParams['processInstanceBusinessKey'] = ObjectSerializer::toQueryValue($process_instance_business_key, null);
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            $queryParams['processInstanceBusinessKeyIn'] = ObjectSerializer::toQueryValue($process_instance_business_key_in, null);
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            $queryParams['processInstanceBusinessKeyLike'] = ObjectSerializer::toQueryValue($process_instance_business_key_like, null);
        }
        // query params
        if ($execution_id !== null) {
            $queryParams['executionId'] = ObjectSerializer::toQueryValue($execution_id, null);
        }
        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_key !== null) {
            $queryParams['processDefinitionKey'] = ObjectSerializer::toQueryValue($process_definition_key, null);
        }
        // query params
        if ($process_definition_name !== null) {
            $queryParams['processDefinitionName'] = ObjectSerializer::toQueryValue($process_definition_name, null);
        }
        // query params
        if ($case_instance_id !== null) {
            $queryParams['caseInstanceId'] = ObjectSerializer::toQueryValue($case_instance_id, null);
        }
        // query params
        if ($case_execution_id !== null) {
            $queryParams['caseExecutionId'] = ObjectSerializer::toQueryValue($case_execution_id, null);
        }
        // query params
        if ($case_definition_id !== null) {
            $queryParams['caseDefinitionId'] = ObjectSerializer::toQueryValue($case_definition_id, null);
        }
        // query params
        if ($case_definition_key !== null) {
            $queryParams['caseDefinitionKey'] = ObjectSerializer::toQueryValue($case_definition_key, null);
        }
        // query params
        if ($case_definition_name !== null) {
            $queryParams['caseDefinitionName'] = ObjectSerializer::toQueryValue($case_definition_name, null);
        }
        // query params
        if ($activity_instance_id_in !== null) {
            $queryParams['activityInstanceIdIn'] = ObjectSerializer::toQueryValue($activity_instance_id_in, null);
        }
        // query params
        if ($task_name !== null) {
            $queryParams['taskName'] = ObjectSerializer::toQueryValue($task_name, null);
        }
        // query params
        if ($task_name_like !== null) {
            $queryParams['taskNameLike'] = ObjectSerializer::toQueryValue($task_name_like, null);
        }
        // query params
        if ($task_description !== null) {
            $queryParams['taskDescription'] = ObjectSerializer::toQueryValue($task_description, null);
        }
        // query params
        if ($task_description_like !== null) {
            $queryParams['taskDescriptionLike'] = ObjectSerializer::toQueryValue($task_description_like, null);
        }
        // query params
        if ($task_definition_key !== null) {
            $queryParams['taskDefinitionKey'] = ObjectSerializer::toQueryValue($task_definition_key, null);
        }
        // query params
        if ($task_definition_key_in !== null) {
            $queryParams['taskDefinitionKeyIn'] = ObjectSerializer::toQueryValue($task_definition_key_in, null);
        }
        // query params
        if ($task_delete_reason !== null) {
            $queryParams['taskDeleteReason'] = ObjectSerializer::toQueryValue($task_delete_reason, null);
        }
        // query params
        if ($task_delete_reason_like !== null) {
            $queryParams['taskDeleteReasonLike'] = ObjectSerializer::toQueryValue($task_delete_reason_like, null);
        }
        // query params
        if ($task_assignee !== null) {
            $queryParams['taskAssignee'] = ObjectSerializer::toQueryValue($task_assignee, null);
        }
        // query params
        if ($task_assignee_like !== null) {
            $queryParams['taskAssigneeLike'] = ObjectSerializer::toQueryValue($task_assignee_like, null);
        }
        // query params
        if ($task_owner !== null) {
            $queryParams['taskOwner'] = ObjectSerializer::toQueryValue($task_owner, null);
        }
        // query params
        if ($task_owner_like !== null) {
            $queryParams['taskOwnerLike'] = ObjectSerializer::toQueryValue($task_owner_like, null);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority, 'int32');
        }
        // query params
        if ($assigned !== null) {
            $queryParams['assigned'] = ObjectSerializer::toQueryValue($assigned, null);
        }
        // query params
        if ($unassigned !== null) {
            $queryParams['unassigned'] = ObjectSerializer::toQueryValue($unassigned, null);
        }
        // query params
        if ($finished !== null) {
            $queryParams['finished'] = ObjectSerializer::toQueryValue($finished, null);
        }
        // query params
        if ($unfinished !== null) {
            $queryParams['unfinished'] = ObjectSerializer::toQueryValue($unfinished, null);
        }
        // query params
        if ($process_finished !== null) {
            $queryParams['processFinished'] = ObjectSerializer::toQueryValue($process_finished, null);
        }
        // query params
        if ($process_unfinished !== null) {
            $queryParams['processUnfinished'] = ObjectSerializer::toQueryValue($process_unfinished, null);
        }
        // query params
        if ($task_due_date !== null) {
            $queryParams['taskDueDate'] = ObjectSerializer::toQueryValue($task_due_date, 'date-time');
        }
        // query params
        if ($task_due_date_before !== null) {
            $queryParams['taskDueDateBefore'] = ObjectSerializer::toQueryValue($task_due_date_before, 'date-time');
        }
        // query params
        if ($task_due_date_after !== null) {
            $queryParams['taskDueDateAfter'] = ObjectSerializer::toQueryValue($task_due_date_after, 'date-time');
        }
        // query params
        if ($without_task_due_date !== null) {
            $queryParams['withoutTaskDueDate'] = ObjectSerializer::toQueryValue($without_task_due_date, null);
        }
        // query params
        if ($task_follow_up_date !== null) {
            $queryParams['taskFollowUpDate'] = ObjectSerializer::toQueryValue($task_follow_up_date, 'date-time');
        }
        // query params
        if ($task_follow_up_date_before !== null) {
            $queryParams['taskFollowUpDateBefore'] = ObjectSerializer::toQueryValue($task_follow_up_date_before, 'date-time');
        }
        // query params
        if ($task_follow_up_date_after !== null) {
            $queryParams['taskFollowUpDateAfter'] = ObjectSerializer::toQueryValue($task_follow_up_date_after, 'date-time');
        }
        // query params
        if ($started_before !== null) {
            $queryParams['startedBefore'] = ObjectSerializer::toQueryValue($started_before, 'date-time');
        }
        // query params
        if ($started_after !== null) {
            $queryParams['startedAfter'] = ObjectSerializer::toQueryValue($started_after, 'date-time');
        }
        // query params
        if ($finished_before !== null) {
            $queryParams['finishedBefore'] = ObjectSerializer::toQueryValue($finished_before, 'date-time');
        }
        // query params
        if ($finished_after !== null) {
            $queryParams['finishedAfter'] = ObjectSerializer::toQueryValue($finished_after, 'date-time');
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($task_variables !== null) {
            $queryParams['taskVariables'] = ObjectSerializer::toQueryValue($task_variables, null);
        }
        // query params
        if ($process_variables !== null) {
            $queryParams['processVariables'] = ObjectSerializer::toQueryValue($process_variables, null);
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            $queryParams['variableNamesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_names_ignore_case, null);
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            $queryParams['variableValuesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_values_ignore_case, null);
        }
        // query params
        if ($task_involved_user !== null) {
            $queryParams['taskInvolvedUser'] = ObjectSerializer::toQueryValue($task_involved_user, null);
        }
        // query params
        if ($task_involved_group !== null) {
            $queryParams['taskInvolvedGroup'] = ObjectSerializer::toQueryValue($task_involved_group, null);
        }
        // query params
        if ($task_had_candidate_user !== null) {
            $queryParams['taskHadCandidateUser'] = ObjectSerializer::toQueryValue($task_had_candidate_user, null);
        }
        // query params
        if ($task_had_candidate_group !== null) {
            $queryParams['taskHadCandidateGroup'] = ObjectSerializer::toQueryValue($task_had_candidate_group, null);
        }
        // query params
        if ($with_candidate_groups !== null) {
            $queryParams['withCandidateGroups'] = ObjectSerializer::toQueryValue($with_candidate_groups, null);
        }
        // query params
        if ($without_candidate_groups !== null) {
            $queryParams['withoutCandidateGroups'] = ObjectSerializer::toQueryValue($without_candidate_groups, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order, null);
        }
        // query params
        if ($first_result !== null) {
            $queryParams['firstResult'] = ObjectSerializer::toQueryValue($first_result, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoricTaskInstancesCount
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\CountResultDto
     */
    public function getHistoricTaskInstancesCount($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        list($response) = $this->getHistoricTaskInstancesCountWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups);
        return $response;
    }

    /**
     * Operation getHistoricTaskInstancesCountWithHttpInfo
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\CountResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoricTaskInstancesCountWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        $returnType = '\Camunda\Client\Model\CountResultDto';
        $request = $this->getHistoricTaskInstancesCountRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoricTaskInstancesCountAsync
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesCountAsync($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        return $this->getHistoricTaskInstancesCountAsyncWithHttpInfo($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoricTaskInstancesCountAsyncWithHttpInfo
     *
     * Get Task Count
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoricTaskInstancesCountAsyncWithHttpInfo($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {
        $returnType = '\Camunda\Client\Model\CountResultDto';
        $request = $this->getHistoricTaskInstancesCountRequest($task_id, $task_parent_task_id, $process_instance_id, $process_instance_business_key, $process_instance_business_key_in, $process_instance_business_key_like, $execution_id, $process_definition_id, $process_definition_key, $process_definition_name, $case_instance_id, $case_execution_id, $case_definition_id, $case_definition_key, $case_definition_name, $activity_instance_id_in, $task_name, $task_name_like, $task_description, $task_description_like, $task_definition_key, $task_definition_key_in, $task_delete_reason, $task_delete_reason_like, $task_assignee, $task_assignee_like, $task_owner, $task_owner_like, $task_priority, $assigned, $unassigned, $finished, $unfinished, $process_finished, $process_unfinished, $task_due_date, $task_due_date_before, $task_due_date_after, $without_task_due_date, $task_follow_up_date, $task_follow_up_date_before, $task_follow_up_date_after, $started_before, $started_after, $finished_before, $finished_after, $tenant_id_in, $without_tenant_id, $task_variables, $process_variables, $variable_names_ignore_case, $variable_values_ignore_case, $task_involved_user, $task_involved_group, $task_had_candidate_user, $task_had_candidate_group, $with_candidate_groups, $without_candidate_groups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoricTaskInstancesCount'
     *
     * @param  string $task_id Filter by task id. (optional)
     * @param  string $task_parent_task_id Filter by parent task id. (optional)
     * @param  string $process_instance_id Filter by process instance id. (optional)
     * @param  string $process_instance_business_key Filter by process instance business key. (optional)
     * @param  string $process_instance_business_key_in Filter by process instances with one of the give business keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Filter by  process instance business key that has the parameter value as a substring. (optional)
     * @param  string $execution_id Filter by the id of the execution that executed the task. (optional)
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $case_execution_id Filter by the id of the case execution that executed the task. (optional)
     * @param  string $case_definition_id Filter by case definition id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed comma-separated activity instance ids. (optional)
     * @param  string $task_name Restrict to tasks that have the given name. (optional)
     * @param  string $task_name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $task_description Restrict to tasks that have the given description. (optional)
     * @param  string $task_description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the passed comma-separated task definition keys. (optional)
     * @param  string $task_delete_reason Restrict to tasks that have the given delete reason. (optional)
     * @param  string $task_delete_reason_like Restrict to tasks that have a delete reason that has the parameter value as a substring. (optional)
     * @param  string $task_assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $task_assignee_like Restrict to tasks that are assigned to users with the parameter value as a substring. (optional)
     * @param  string $task_owner Restrict to tasks that the given user owns. (optional)
     * @param  string $task_owner_like Restrict to tasks that are owned by users with the parameter value as a substring. (optional)
     * @param  int $task_priority Restrict to tasks that have the given priority. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional)
     * @param  bool $finished Only include finished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $unfinished Only include unfinished tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_finished Only include tasks of finished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $process_unfinished Only include tasks of unfinished processes. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_due_date_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  bool $without_task_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  \DateTime $task_follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $task_follow_up_date_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_before Restrict to tasks that were started before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $started_after Restrict to tasks that were started after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_before Restrict to tasks that were finished before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $finished_after Restrict to tasks that were finished after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A task instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include historic task instances that belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value. **Note:** Values are always treated as &#x60;String&#x60; objects on server side.   Valid operator values are: * &#x60;eq&#x60; - equal to; * &#x60;neq&#x60; - not equal to; * &#x60;gt&#x60; - greater than; * &#x60;gteq&#x60; - greater than or equal to; * &#x60;lt&#x60; - lower than; * &#x60;lteq&#x60; - lower than or equal to; * &#x60;like&#x60;; * &#x60;notLike&#x60;.  &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match the variable name provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableName** and **variablename** are treated as equal. (optional)
     * @param  bool $variable_values_ignore_case Match the variable value provided in &#x60;taskVariables&#x60; and &#x60;processVariables&#x60; case- insensitively. If set to &#x60;true&#x60; **variableValue** and **variablevalue** are treated as equal. (optional)
     * @param  string $task_involved_user Restrict to tasks with a historic identity link to the given user. (optional)
     * @param  string $task_involved_group Restrict to tasks with a historic identity link to the given group. (optional)
     * @param  string $task_had_candidate_user Restrict to tasks with a historic identity link to the given candidate user. (optional)
     * @param  string $task_had_candidate_group Restrict to tasks with a historic identity link to the given candidate group. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoricTaskInstancesCountRequest($task_id = null, $task_parent_task_id = null, $process_instance_id = null, $process_instance_business_key = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $execution_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_name = null, $case_instance_id = null, $case_execution_id = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $activity_instance_id_in = null, $task_name = null, $task_name_like = null, $task_description = null, $task_description_like = null, $task_definition_key = null, $task_definition_key_in = null, $task_delete_reason = null, $task_delete_reason_like = null, $task_assignee = null, $task_assignee_like = null, $task_owner = null, $task_owner_like = null, $task_priority = null, $assigned = null, $unassigned = null, $finished = null, $unfinished = null, $process_finished = null, $process_unfinished = null, $task_due_date = null, $task_due_date_before = null, $task_due_date_after = null, $without_task_due_date = null, $task_follow_up_date = null, $task_follow_up_date_before = null, $task_follow_up_date_after = null, $started_before = null, $started_after = null, $finished_before = null, $finished_after = null, $tenant_id_in = null, $without_tenant_id = null, $task_variables = null, $process_variables = null, $variable_names_ignore_case = null, $variable_values_ignore_case = null, $task_involved_user = null, $task_involved_group = null, $task_had_candidate_user = null, $task_had_candidate_group = null, $with_candidate_groups = null, $without_candidate_groups = null)
    {

        $resourcePath = '/history/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_id !== null) {
            $queryParams['taskId'] = ObjectSerializer::toQueryValue($task_id, null);
        }
        // query params
        if ($task_parent_task_id !== null) {
            $queryParams['taskParentTaskId'] = ObjectSerializer::toQueryValue($task_parent_task_id, null);
        }
        // query params
        if ($process_instance_id !== null) {
            $queryParams['processInstanceId'] = ObjectSerializer::toQueryValue($process_instance_id, null);
        }
        // query params
        if ($process_instance_business_key !== null) {
            $queryParams['processInstanceBusinessKey'] = ObjectSerializer::toQueryValue($process_instance_business_key, null);
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            $queryParams['processInstanceBusinessKeyIn'] = ObjectSerializer::toQueryValue($process_instance_business_key_in, null);
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            $queryParams['processInstanceBusinessKeyLike'] = ObjectSerializer::toQueryValue($process_instance_business_key_like, null);
        }
        // query params
        if ($execution_id !== null) {
            $queryParams['executionId'] = ObjectSerializer::toQueryValue($execution_id, null);
        }
        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_key !== null) {
            $queryParams['processDefinitionKey'] = ObjectSerializer::toQueryValue($process_definition_key, null);
        }
        // query params
        if ($process_definition_name !== null) {
            $queryParams['processDefinitionName'] = ObjectSerializer::toQueryValue($process_definition_name, null);
        }
        // query params
        if ($case_instance_id !== null) {
            $queryParams['caseInstanceId'] = ObjectSerializer::toQueryValue($case_instance_id, null);
        }
        // query params
        if ($case_execution_id !== null) {
            $queryParams['caseExecutionId'] = ObjectSerializer::toQueryValue($case_execution_id, null);
        }
        // query params
        if ($case_definition_id !== null) {
            $queryParams['caseDefinitionId'] = ObjectSerializer::toQueryValue($case_definition_id, null);
        }
        // query params
        if ($case_definition_key !== null) {
            $queryParams['caseDefinitionKey'] = ObjectSerializer::toQueryValue($case_definition_key, null);
        }
        // query params
        if ($case_definition_name !== null) {
            $queryParams['caseDefinitionName'] = ObjectSerializer::toQueryValue($case_definition_name, null);
        }
        // query params
        if ($activity_instance_id_in !== null) {
            $queryParams['activityInstanceIdIn'] = ObjectSerializer::toQueryValue($activity_instance_id_in, null);
        }
        // query params
        if ($task_name !== null) {
            $queryParams['taskName'] = ObjectSerializer::toQueryValue($task_name, null);
        }
        // query params
        if ($task_name_like !== null) {
            $queryParams['taskNameLike'] = ObjectSerializer::toQueryValue($task_name_like, null);
        }
        // query params
        if ($task_description !== null) {
            $queryParams['taskDescription'] = ObjectSerializer::toQueryValue($task_description, null);
        }
        // query params
        if ($task_description_like !== null) {
            $queryParams['taskDescriptionLike'] = ObjectSerializer::toQueryValue($task_description_like, null);
        }
        // query params
        if ($task_definition_key !== null) {
            $queryParams['taskDefinitionKey'] = ObjectSerializer::toQueryValue($task_definition_key, null);
        }
        // query params
        if ($task_definition_key_in !== null) {
            $queryParams['taskDefinitionKeyIn'] = ObjectSerializer::toQueryValue($task_definition_key_in, null);
        }
        // query params
        if ($task_delete_reason !== null) {
            $queryParams['taskDeleteReason'] = ObjectSerializer::toQueryValue($task_delete_reason, null);
        }
        // query params
        if ($task_delete_reason_like !== null) {
            $queryParams['taskDeleteReasonLike'] = ObjectSerializer::toQueryValue($task_delete_reason_like, null);
        }
        // query params
        if ($task_assignee !== null) {
            $queryParams['taskAssignee'] = ObjectSerializer::toQueryValue($task_assignee, null);
        }
        // query params
        if ($task_assignee_like !== null) {
            $queryParams['taskAssigneeLike'] = ObjectSerializer::toQueryValue($task_assignee_like, null);
        }
        // query params
        if ($task_owner !== null) {
            $queryParams['taskOwner'] = ObjectSerializer::toQueryValue($task_owner, null);
        }
        // query params
        if ($task_owner_like !== null) {
            $queryParams['taskOwnerLike'] = ObjectSerializer::toQueryValue($task_owner_like, null);
        }
        // query params
        if ($task_priority !== null) {
            $queryParams['taskPriority'] = ObjectSerializer::toQueryValue($task_priority, 'int32');
        }
        // query params
        if ($assigned !== null) {
            $queryParams['assigned'] = ObjectSerializer::toQueryValue($assigned, null);
        }
        // query params
        if ($unassigned !== null) {
            $queryParams['unassigned'] = ObjectSerializer::toQueryValue($unassigned, null);
        }
        // query params
        if ($finished !== null) {
            $queryParams['finished'] = ObjectSerializer::toQueryValue($finished, null);
        }
        // query params
        if ($unfinished !== null) {
            $queryParams['unfinished'] = ObjectSerializer::toQueryValue($unfinished, null);
        }
        // query params
        if ($process_finished !== null) {
            $queryParams['processFinished'] = ObjectSerializer::toQueryValue($process_finished, null);
        }
        // query params
        if ($process_unfinished !== null) {
            $queryParams['processUnfinished'] = ObjectSerializer::toQueryValue($process_unfinished, null);
        }
        // query params
        if ($task_due_date !== null) {
            $queryParams['taskDueDate'] = ObjectSerializer::toQueryValue($task_due_date, 'date-time');
        }
        // query params
        if ($task_due_date_before !== null) {
            $queryParams['taskDueDateBefore'] = ObjectSerializer::toQueryValue($task_due_date_before, 'date-time');
        }
        // query params
        if ($task_due_date_after !== null) {
            $queryParams['taskDueDateAfter'] = ObjectSerializer::toQueryValue($task_due_date_after, 'date-time');
        }
        // query params
        if ($without_task_due_date !== null) {
            $queryParams['withoutTaskDueDate'] = ObjectSerializer::toQueryValue($without_task_due_date, null);
        }
        // query params
        if ($task_follow_up_date !== null) {
            $queryParams['taskFollowUpDate'] = ObjectSerializer::toQueryValue($task_follow_up_date, 'date-time');
        }
        // query params
        if ($task_follow_up_date_before !== null) {
            $queryParams['taskFollowUpDateBefore'] = ObjectSerializer::toQueryValue($task_follow_up_date_before, 'date-time');
        }
        // query params
        if ($task_follow_up_date_after !== null) {
            $queryParams['taskFollowUpDateAfter'] = ObjectSerializer::toQueryValue($task_follow_up_date_after, 'date-time');
        }
        // query params
        if ($started_before !== null) {
            $queryParams['startedBefore'] = ObjectSerializer::toQueryValue($started_before, 'date-time');
        }
        // query params
        if ($started_after !== null) {
            $queryParams['startedAfter'] = ObjectSerializer::toQueryValue($started_after, 'date-time');
        }
        // query params
        if ($finished_before !== null) {
            $queryParams['finishedBefore'] = ObjectSerializer::toQueryValue($finished_before, 'date-time');
        }
        // query params
        if ($finished_after !== null) {
            $queryParams['finishedAfter'] = ObjectSerializer::toQueryValue($finished_after, 'date-time');
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($task_variables !== null) {
            $queryParams['taskVariables'] = ObjectSerializer::toQueryValue($task_variables, null);
        }
        // query params
        if ($process_variables !== null) {
            $queryParams['processVariables'] = ObjectSerializer::toQueryValue($process_variables, null);
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            $queryParams['variableNamesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_names_ignore_case, null);
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            $queryParams['variableValuesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_values_ignore_case, null);
        }
        // query params
        if ($task_involved_user !== null) {
            $queryParams['taskInvolvedUser'] = ObjectSerializer::toQueryValue($task_involved_user, null);
        }
        // query params
        if ($task_involved_group !== null) {
            $queryParams['taskInvolvedGroup'] = ObjectSerializer::toQueryValue($task_involved_group, null);
        }
        // query params
        if ($task_had_candidate_user !== null) {
            $queryParams['taskHadCandidateUser'] = ObjectSerializer::toQueryValue($task_had_candidate_user, null);
        }
        // query params
        if ($task_had_candidate_group !== null) {
            $queryParams['taskHadCandidateGroup'] = ObjectSerializer::toQueryValue($task_had_candidate_group, null);
        }
        // query params
        if ($with_candidate_groups !== null) {
            $queryParams['withCandidateGroups'] = ObjectSerializer::toQueryValue($with_candidate_groups, null);
        }
        // query params
        if ($without_candidate_groups !== null) {
            $queryParams['withoutCandidateGroups'] = ObjectSerializer::toQueryValue($without_candidate_groups, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryHistoricTaskInstances
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\HistoricTaskInstanceDto[]
     */
    public function queryHistoricTaskInstances($body = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->queryHistoricTaskInstancesWithHttpInfo($body, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation queryHistoricTaskInstancesWithHttpInfo
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\HistoricTaskInstanceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function queryHistoricTaskInstancesWithHttpInfo($body = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Camunda\Client\Model\HistoricTaskInstanceDto[]';
        $request = $this->queryHistoricTaskInstancesRequest($body, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\HistoricTaskInstanceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryHistoricTaskInstancesAsync
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesAsync($body = null, $first_result = null, $max_results = null)
    {
        return $this->queryHistoricTaskInstancesAsyncWithHttpInfo($body, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryHistoricTaskInstancesAsyncWithHttpInfo
     *
     * Get Tasks (Historic) (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesAsyncWithHttpInfo($body = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Camunda\Client\Model\HistoricTaskInstanceDto[]';
        $request = $this->queryHistoricTaskInstancesRequest($body, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryHistoricTaskInstances'
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryHistoricTaskInstancesRequest($body = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/history/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($first_result !== null) {
            $queryParams['firstResult'] = ObjectSerializer::toQueryValue($first_result, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryHistoricTaskInstancesCount
     *
     * Get Task Count (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\CountResultDto
     */
    public function queryHistoricTaskInstancesCount($body = null)
    {
        list($response) = $this->queryHistoricTaskInstancesCountWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation queryHistoricTaskInstancesCountWithHttpInfo
     *
     * Get Task Count (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\CountResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryHistoricTaskInstancesCountWithHttpInfo($body = null)
    {
        $returnType = '\Camunda\Client\Model\CountResultDto';
        $request = $this->queryHistoricTaskInstancesCountRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryHistoricTaskInstancesCountAsync
     *
     * Get Task Count (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesCountAsync($body = null)
    {
        return $this->queryHistoricTaskInstancesCountAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryHistoricTaskInstancesCountAsyncWithHttpInfo
     *
     * Get Task Count (POST)
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryHistoricTaskInstancesCountAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Camunda\Client\Model\CountResultDto';
        $request = $this->queryHistoricTaskInstancesCountRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryHistoricTaskInstancesCount'
     *
     * @param  \Camunda\Client\Model\HistoricTaskInstanceQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryHistoricTaskInstancesCountRequest($body = null)
    {

        $resourcePath = '/history/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
