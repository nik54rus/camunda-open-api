<?php
/**
 * ProcessDefinitionApi
 * PHP version 5
 *
 * @category Class
 * @package  Camunda\Client
 * @author   Nik54rus
 * @link     https://github.com/nik54rus/camunda-open-api
 */

/**
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.21.1-ee
 * 
 * Generated by: https://github.com/nik54rus/camunda-open-api.git
 * Camunda Codegen version: 3.0.56
 */


namespace Camunda\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Camunda\Client\ApiException;
use Camunda\Client\Configuration;
use Camunda\Client\HeaderSelector;
use Camunda\Client\ObjectSerializer;

/**
 * ProcessDefinitionApi Class Doc Comment
 *
 * @category Class
 * @package  Camunda\Client
 * @author   Nik54rus
 * @link     https://github.com/nik54rus/camunda-open-api
 */
class ProcessDefinitionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteProcessDefinition
     *
     * Delete
     *
     * @param  string $id The id of the process definition to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProcessDefinition($id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $this->deleteProcessDefinitionWithHttpInfo($id, $cascade, $skip_custom_listeners, $skip_io_mappings);
    }

    /**
     * Operation deleteProcessDefinitionWithHttpInfo
     *
     * Delete
     *
     * @param  string $id The id of the process definition to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProcessDefinitionWithHttpInfo($id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $returnType = '';
        $request = $this->deleteProcessDefinitionRequest($id, $cascade, $skip_custom_listeners, $skip_io_mappings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProcessDefinitionAsync
     *
     * Delete
     *
     * @param  string $id The id of the process definition to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessDefinitionAsync($id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        return $this->deleteProcessDefinitionAsyncWithHttpInfo($id, $cascade, $skip_custom_listeners, $skip_io_mappings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProcessDefinitionAsyncWithHttpInfo
     *
     * Delete
     *
     * @param  string $id The id of the process definition to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessDefinitionAsyncWithHttpInfo($id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $returnType = '';
        $request = $this->deleteProcessDefinitionRequest($id, $cascade, $skip_custom_listeners, $skip_io_mappings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProcessDefinition'
     *
     * @param  string $id The id of the process definition to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProcessDefinitionRequest($id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteProcessDefinition'
            );
        }

        $resourcePath = '/process-definition/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($cascade !== null) {
            $queryParams['cascade'] = ObjectSerializer::toQueryValue($cascade, null);
        }
        // query params
        if ($skip_custom_listeners !== null) {
            $queryParams['skipCustomListeners'] = ObjectSerializer::toQueryValue($skip_custom_listeners, null);
        }
        // query params
        if ($skip_io_mappings !== null) {
            $queryParams['skipIoMappings'] = ObjectSerializer::toQueryValue($skip_io_mappings, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProcessDefinitionsByKey
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProcessDefinitionsByKey($key, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $this->deleteProcessDefinitionsByKeyWithHttpInfo($key, $cascade, $skip_custom_listeners, $skip_io_mappings);
    }

    /**
     * Operation deleteProcessDefinitionsByKeyWithHttpInfo
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProcessDefinitionsByKeyWithHttpInfo($key, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $returnType = '';
        $request = $this->deleteProcessDefinitionsByKeyRequest($key, $cascade, $skip_custom_listeners, $skip_io_mappings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProcessDefinitionsByKeyAsync
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessDefinitionsByKeyAsync($key, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        return $this->deleteProcessDefinitionsByKeyAsyncWithHttpInfo($key, $cascade, $skip_custom_listeners, $skip_io_mappings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProcessDefinitionsByKeyAsyncWithHttpInfo
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessDefinitionsByKeyAsyncWithHttpInfo($key, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $returnType = '';
        $request = $this->deleteProcessDefinitionsByKeyRequest($key, $cascade, $skip_custom_listeners, $skip_io_mappings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProcessDefinitionsByKey'
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProcessDefinitionsByKeyRequest($key, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling deleteProcessDefinitionsByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($cascade !== null) {
            $queryParams['cascade'] = ObjectSerializer::toQueryValue($cascade, null);
        }
        // query params
        if ($skip_custom_listeners !== null) {
            $queryParams['skipCustomListeners'] = ObjectSerializer::toQueryValue($skip_custom_listeners, null);
        }
        // query params
        if ($skip_io_mappings !== null) {
            $queryParams['skipIoMappings'] = ObjectSerializer::toQueryValue($skip_io_mappings, null);
        }

        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProcessDefinitionsByKeyAndTenantId
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProcessDefinitionsByKeyAndTenantId($key, $tenant_id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $this->deleteProcessDefinitionsByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $cascade, $skip_custom_listeners, $skip_io_mappings);
    }

    /**
     * Operation deleteProcessDefinitionsByKeyAndTenantIdWithHttpInfo
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProcessDefinitionsByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $returnType = '';
        $request = $this->deleteProcessDefinitionsByKeyAndTenantIdRequest($key, $tenant_id, $cascade, $skip_custom_listeners, $skip_io_mappings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProcessDefinitionsByKeyAndTenantIdAsync
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessDefinitionsByKeyAndTenantIdAsync($key, $tenant_id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        return $this->deleteProcessDefinitionsByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $cascade, $skip_custom_listeners, $skip_io_mappings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProcessDefinitionsByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Delete By Key
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessDefinitionsByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        $returnType = '';
        $request = $this->deleteProcessDefinitionsByKeyAndTenantIdRequest($key, $tenant_id, $cascade, $skip_custom_listeners, $skip_io_mappings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProcessDefinitionsByKeyAndTenantId'
     *
     * @param  string $key The key of the process definitions to be deleted. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted. (optional)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProcessDefinitionsByKeyAndTenantIdRequest($key, $tenant_id, $cascade = null, $skip_custom_listeners = 'false', $skip_io_mappings = 'false')
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling deleteProcessDefinitionsByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling deleteProcessDefinitionsByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($cascade !== null) {
            $queryParams['cascade'] = ObjectSerializer::toQueryValue($cascade, null);
        }
        // query params
        if ($skip_custom_listeners !== null) {
            $queryParams['skipCustomListeners'] = ObjectSerializer::toQueryValue($skip_custom_listeners, null);
        }
        // query params
        if ($skip_io_mappings !== null) {
            $queryParams['skipIoMappings'] = ObjectSerializer::toQueryValue($skip_io_mappings, null);
        }

        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityStatistics
     *
     * Get Activity Instance Statistics
     *
     * @param  string $id The id of the process definition. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ActivityStatisticsResultDto[]
     */
    public function getActivityStatistics($id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        list($response) = $this->getActivityStatisticsWithHttpInfo($id, $failed_jobs, $incidents, $incidents_for_type);
        return $response;
    }

    /**
     * Operation getActivityStatisticsWithHttpInfo
     *
     * Get Activity Instance Statistics
     *
     * @param  string $id The id of the process definition. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ActivityStatisticsResultDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityStatisticsWithHttpInfo($id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        $returnType = '\Camunda\Client\Model\ActivityStatisticsResultDto[]';
        $request = $this->getActivityStatisticsRequest($id, $failed_jobs, $incidents, $incidents_for_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ActivityStatisticsResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityStatisticsAsync
     *
     * Get Activity Instance Statistics
     *
     * @param  string $id The id of the process definition. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityStatisticsAsync($id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        return $this->getActivityStatisticsAsyncWithHttpInfo($id, $failed_jobs, $incidents, $incidents_for_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityStatisticsAsyncWithHttpInfo
     *
     * Get Activity Instance Statistics
     *
     * @param  string $id The id of the process definition. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityStatisticsAsyncWithHttpInfo($id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        $returnType = '\Camunda\Client\Model\ActivityStatisticsResultDto[]';
        $request = $this->getActivityStatisticsRequest($id, $failed_jobs, $incidents, $incidents_for_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityStatistics'
     *
     * @param  string $id The id of the process definition. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityStatisticsRequest($id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getActivityStatistics'
            );
        }

        $resourcePath = '/process-definition/{id}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($failed_jobs !== null) {
            $queryParams['failedJobs'] = ObjectSerializer::toQueryValue($failed_jobs, null);
        }
        // query params
        if ($incidents !== null) {
            $queryParams['incidents'] = ObjectSerializer::toQueryValue($incidents, null);
        }
        // query params
        if ($incidents_for_type !== null) {
            $queryParams['incidentsForType'] = ObjectSerializer::toQueryValue($incidents_for_type, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKey
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ActivityStatisticsResultDto[]
     */
    public function getActivityStatisticsByProcessDefinitionKey($key, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        list($response) = $this->getActivityStatisticsByProcessDefinitionKeyWithHttpInfo($key, $failed_jobs, $incidents, $incidents_for_type);
        return $response;
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKeyWithHttpInfo
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ActivityStatisticsResultDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityStatisticsByProcessDefinitionKeyWithHttpInfo($key, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        $returnType = '\Camunda\Client\Model\ActivityStatisticsResultDto[]';
        $request = $this->getActivityStatisticsByProcessDefinitionKeyRequest($key, $failed_jobs, $incidents, $incidents_for_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ActivityStatisticsResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKeyAsync
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityStatisticsByProcessDefinitionKeyAsync($key, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        return $this->getActivityStatisticsByProcessDefinitionKeyAsyncWithHttpInfo($key, $failed_jobs, $incidents, $incidents_for_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKeyAsyncWithHttpInfo
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityStatisticsByProcessDefinitionKeyAsyncWithHttpInfo($key, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        $returnType = '\Camunda\Client\Model\ActivityStatisticsResultDto[]';
        $request = $this->getActivityStatisticsByProcessDefinitionKeyRequest($key, $failed_jobs, $incidents, $incidents_for_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityStatisticsByProcessDefinitionKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityStatisticsByProcessDefinitionKeyRequest($key, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getActivityStatisticsByProcessDefinitionKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($failed_jobs !== null) {
            $queryParams['failedJobs'] = ObjectSerializer::toQueryValue($failed_jobs, null);
        }
        // query params
        if ($incidents !== null) {
            $queryParams['incidents'] = ObjectSerializer::toQueryValue($incidents, null);
        }
        // query params
        if ($incidents_for_type !== null) {
            $queryParams['incidentsForType'] = ObjectSerializer::toQueryValue($incidents_for_type, null);
        }

        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKeyAndTenantId
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ActivityStatisticsResultDto[]
     */
    public function getActivityStatisticsByProcessDefinitionKeyAndTenantId($key, $tenant_id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        list($response) = $this->getActivityStatisticsByProcessDefinitionKeyAndTenantIdWithHttpInfo($key, $tenant_id, $failed_jobs, $incidents, $incidents_for_type);
        return $response;
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKeyAndTenantIdWithHttpInfo
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ActivityStatisticsResultDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityStatisticsByProcessDefinitionKeyAndTenantIdWithHttpInfo($key, $tenant_id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        $returnType = '\Camunda\Client\Model\ActivityStatisticsResultDto[]';
        $request = $this->getActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest($key, $tenant_id, $failed_jobs, $incidents, $incidents_for_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ActivityStatisticsResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKeyAndTenantIdAsync
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityStatisticsByProcessDefinitionKeyAndTenantIdAsync($key, $tenant_id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        return $this->getActivityStatisticsByProcessDefinitionKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $failed_jobs, $incidents, $incidents_for_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityStatisticsByProcessDefinitionKeyAndTenantIdAsyncWithHttpInfo
     *
     * Get Activity Instance Statistics
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityStatisticsByProcessDefinitionKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        $returnType = '\Camunda\Client\Model\ActivityStatisticsResultDto[]';
        $request = $this->getActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest($key, $tenant_id, $failed_jobs, $incidents, $incidents_for_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityStatisticsByProcessDefinitionKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityStatisticsByProcessDefinitionKeyAndTenantIdRequest($key, $tenant_id, $failed_jobs = null, $incidents = null, $incidents_for_type = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($failed_jobs !== null) {
            $queryParams['failedJobs'] = ObjectSerializer::toQueryValue($failed_jobs, null);
        }
        // query params
        if ($incidents !== null) {
            $queryParams['incidents'] = ObjectSerializer::toQueryValue($incidents, null);
        }
        // query params
        if ($incidents_for_type !== null) {
            $queryParams['incidentsForType'] = ObjectSerializer::toQueryValue($incidents_for_type, null);
        }

        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeployedStartForm
     *
     * Get Deployed Start Form
     *
     * @param  string $id The id of the process definition to get the deployed start form for. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getDeployedStartForm($id)
    {
        list($response) = $this->getDeployedStartFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDeployedStartFormWithHttpInfo
     *
     * Get Deployed Start Form
     *
     * @param  string $id The id of the process definition to get the deployed start form for. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeployedStartFormWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getDeployedStartFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeployedStartFormAsync
     *
     * Get Deployed Start Form
     *
     * @param  string $id The id of the process definition to get the deployed start form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedStartFormAsync($id)
    {
        return $this->getDeployedStartFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeployedStartFormAsyncWithHttpInfo
     *
     * Get Deployed Start Form
     *
     * @param  string $id The id of the process definition to get the deployed start form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedStartFormAsyncWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getDeployedStartFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeployedStartForm'
     *
     * @param  string $id The id of the process definition to get the deployed start form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeployedStartFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeployedStartForm'
            );
        }

        $resourcePath = '/process-definition/{id}/deployed-start-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeployedStartFormByKey
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getDeployedStartFormByKey($key)
    {
        list($response) = $this->getDeployedStartFormByKeyWithHttpInfo($key);
        return $response;
    }

    /**
     * Operation getDeployedStartFormByKeyWithHttpInfo
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeployedStartFormByKeyWithHttpInfo($key)
    {
        $returnType = 'string';
        $request = $this->getDeployedStartFormByKeyRequest($key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeployedStartFormByKeyAsync
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedStartFormByKeyAsync($key)
    {
        return $this->getDeployedStartFormByKeyAsyncWithHttpInfo($key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeployedStartFormByKeyAsyncWithHttpInfo
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedStartFormByKeyAsyncWithHttpInfo($key)
    {
        $returnType = 'string';
        $request = $this->getDeployedStartFormByKeyRequest($key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeployedStartFormByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeployedStartFormByKeyRequest($key)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getDeployedStartFormByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/deployed-start-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeployedStartFormByKeyAndTenantId
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getDeployedStartFormByKeyAndTenantId($key, $tenant_id)
    {
        list($response) = $this->getDeployedStartFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id);
        return $response;
    }

    /**
     * Operation getDeployedStartFormByKeyAndTenantIdWithHttpInfo
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeployedStartFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id)
    {
        $returnType = 'string';
        $request = $this->getDeployedStartFormByKeyAndTenantIdRequest($key, $tenant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeployedStartFormByKeyAndTenantIdAsync
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedStartFormByKeyAndTenantIdAsync($key, $tenant_id)
    {
        return $this->getDeployedStartFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeployedStartFormByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Get Deployed Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedStartFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
    {
        $returnType = 'string';
        $request = $this->getDeployedStartFormByKeyAndTenantIdRequest($key, $tenant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeployedStartFormByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definitions belong to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeployedStartFormByKeyAndTenantIdRequest($key, $tenant_id)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getDeployedStartFormByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getDeployedStartFormByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/deployed-start-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLatestProcessDefinitionByTenantId
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionDto
     */
    public function getLatestProcessDefinitionByTenantId($key, $tenant_id)
    {
        list($response) = $this->getLatestProcessDefinitionByTenantIdWithHttpInfo($key, $tenant_id);
        return $response;
    }

    /**
     * Operation getLatestProcessDefinitionByTenantIdWithHttpInfo
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLatestProcessDefinitionByTenantIdWithHttpInfo($key, $tenant_id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto';
        $request = $this->getLatestProcessDefinitionByTenantIdRequest($key, $tenant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLatestProcessDefinitionByTenantIdAsync
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLatestProcessDefinitionByTenantIdAsync($key, $tenant_id)
    {
        return $this->getLatestProcessDefinitionByTenantIdAsyncWithHttpInfo($key, $tenant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLatestProcessDefinitionByTenantIdAsyncWithHttpInfo
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLatestProcessDefinitionByTenantIdAsyncWithHttpInfo($key, $tenant_id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto';
        $request = $this->getLatestProcessDefinitionByTenantIdRequest($key, $tenant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLatestProcessDefinitionByTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLatestProcessDefinitionByTenantIdRequest($key, $tenant_id)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getLatestProcessDefinitionByTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getLatestProcessDefinitionByTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinition
     *
     * Get
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionDto
     */
    public function getProcessDefinition($id)
    {
        list($response) = $this->getProcessDefinitionWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProcessDefinitionWithHttpInfo
     *
     * Get
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto';
        $request = $this->getProcessDefinitionRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionAsync
     *
     * Get
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionAsync($id)
    {
        return $this->getProcessDefinitionAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionAsyncWithHttpInfo
     *
     * Get
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionAsyncWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto';
        $request = $this->getProcessDefinitionRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinition'
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessDefinition'
            );
        }

        $resourcePath = '/process-definition/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionBpmn20Xml
     *
     * Get XML
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionDiagramDto
     */
    public function getProcessDefinitionBpmn20Xml($id)
    {
        list($response) = $this->getProcessDefinitionBpmn20XmlWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlWithHttpInfo
     *
     * Get XML
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionDiagramDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionBpmn20XmlWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDiagramDto';
        $request = $this->getProcessDefinitionBpmn20XmlRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionDiagramDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlAsync
     *
     * Get XML
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionBpmn20XmlAsync($id)
    {
        return $this->getProcessDefinitionBpmn20XmlAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlAsyncWithHttpInfo
     *
     * Get XML
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionBpmn20XmlAsyncWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDiagramDto';
        $request = $this->getProcessDefinitionBpmn20XmlRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionBpmn20Xml'
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionBpmn20XmlRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessDefinitionBpmn20Xml'
            );
        }

        $resourcePath = '/process-definition/{id}/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKey
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionDiagramDto
     */
    public function getProcessDefinitionBpmn20XmlByKey($key)
    {
        list($response) = $this->getProcessDefinitionBpmn20XmlByKeyWithHttpInfo($key);
        return $response;
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKeyWithHttpInfo
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionDiagramDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionBpmn20XmlByKeyWithHttpInfo($key)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDiagramDto';
        $request = $this->getProcessDefinitionBpmn20XmlByKeyRequest($key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionDiagramDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKeyAsync
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionBpmn20XmlByKeyAsync($key)
    {
        return $this->getProcessDefinitionBpmn20XmlByKeyAsyncWithHttpInfo($key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKeyAsyncWithHttpInfo
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionBpmn20XmlByKeyAsyncWithHttpInfo($key)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDiagramDto';
        $request = $this->getProcessDefinitionBpmn20XmlByKeyRequest($key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionBpmn20XmlByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionBpmn20XmlByKeyRequest($key)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getProcessDefinitionBpmn20XmlByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKeyAndTenantId
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionDiagramDto
     */
    public function getProcessDefinitionBpmn20XmlByKeyAndTenantId($key, $tenant_id)
    {
        list($response) = $this->getProcessDefinitionBpmn20XmlByKeyAndTenantIdWithHttpInfo($key, $tenant_id);
        return $response;
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKeyAndTenantIdWithHttpInfo
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionDiagramDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionBpmn20XmlByKeyAndTenantIdWithHttpInfo($key, $tenant_id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDiagramDto';
        $request = $this->getProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest($key, $tenant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionDiagramDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKeyAndTenantIdAsync
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionBpmn20XmlByKeyAndTenantIdAsync($key, $tenant_id)
    {
        return $this->getProcessDefinitionBpmn20XmlByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionBpmn20XmlByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Get XML
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionBpmn20XmlByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDiagramDto';
        $request = $this->getProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest($key, $tenant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionBpmn20XmlByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) whose XML should be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionBpmn20XmlByKeyAndTenantIdRequest($key, $tenant_id)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/xml';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionByKey
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionDto
     */
    public function getProcessDefinitionByKey($key)
    {
        list($response) = $this->getProcessDefinitionByKeyWithHttpInfo($key);
        return $response;
    }

    /**
     * Operation getProcessDefinitionByKeyWithHttpInfo
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionByKeyWithHttpInfo($key)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto';
        $request = $this->getProcessDefinitionByKeyRequest($key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionByKeyAsync
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionByKeyAsync($key)
    {
        return $this->getProcessDefinitionByKeyAsyncWithHttpInfo($key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionByKeyAsyncWithHttpInfo
     *
     * Get
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionByKeyAsyncWithHttpInfo($key)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto';
        $request = $this->getProcessDefinitionByKeyRequest($key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionByKeyRequest($key)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getProcessDefinitionByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionDiagram
     *
     * Get Diagram
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getProcessDefinitionDiagram($id)
    {
        list($response) = $this->getProcessDefinitionDiagramWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProcessDefinitionDiagramWithHttpInfo
     *
     * Get Diagram
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionDiagramWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getProcessDefinitionDiagramRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionDiagramAsync
     *
     * Get Diagram
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionDiagramAsync($id)
    {
        return $this->getProcessDefinitionDiagramAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionDiagramAsyncWithHttpInfo
     *
     * Get Diagram
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionDiagramAsyncWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getProcessDefinitionDiagramRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionDiagram'
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionDiagramRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessDefinitionDiagram'
            );
        }

        $resourcePath = '/process-definition/{id}/diagram';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream', '*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream', '*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionDiagramByKey
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getProcessDefinitionDiagramByKey($key)
    {
        list($response) = $this->getProcessDefinitionDiagramByKeyWithHttpInfo($key);
        return $response;
    }

    /**
     * Operation getProcessDefinitionDiagramByKeyWithHttpInfo
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionDiagramByKeyWithHttpInfo($key)
    {
        $returnType = 'string';
        $request = $this->getProcessDefinitionDiagramByKeyRequest($key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionDiagramByKeyAsync
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionDiagramByKeyAsync($key)
    {
        return $this->getProcessDefinitionDiagramByKeyAsyncWithHttpInfo($key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionDiagramByKeyAsyncWithHttpInfo
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionDiagramByKeyAsyncWithHttpInfo($key)
    {
        $returnType = 'string';
        $request = $this->getProcessDefinitionDiagramByKeyRequest($key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionDiagramByKey'
     *
     * @param  string $key The key of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionDiagramByKeyRequest($key)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getProcessDefinitionDiagramByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/diagram';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream', '*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream', '*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionDiagramByKeyAndTenantId
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getProcessDefinitionDiagramByKeyAndTenantId($key, $tenant_id)
    {
        list($response) = $this->getProcessDefinitionDiagramByKeyAndTenantIdWithHttpInfo($key, $tenant_id);
        return $response;
    }

    /**
     * Operation getProcessDefinitionDiagramByKeyAndTenantIdWithHttpInfo
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionDiagramByKeyAndTenantIdWithHttpInfo($key, $tenant_id)
    {
        $returnType = 'string';
        $request = $this->getProcessDefinitionDiagramByKeyAndTenantIdRequest($key, $tenant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionDiagramByKeyAndTenantIdAsync
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionDiagramByKeyAndTenantIdAsync($key, $tenant_id)
    {
        return $this->getProcessDefinitionDiagramByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionDiagramByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Get Diagram
     *
     * @param  string $key The key of the process definition. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionDiagramByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
    {
        $returnType = 'string';
        $request = $this->getProcessDefinitionDiagramByKeyAndTenantIdRequest($key, $tenant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionDiagramByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionDiagramByKeyAndTenantIdRequest($key, $tenant_id)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getProcessDefinitionDiagramByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getProcessDefinitionDiagramByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/diagram';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream', '*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream', '*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionStatistics
     *
     * Get Process Instance Statistics
     *
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  bool $root_incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionStatisticsResultDto[]
     */
    public function getProcessDefinitionStatistics($failed_jobs = null, $incidents = null, $incidents_for_type = null, $root_incidents = null)
    {
        list($response) = $this->getProcessDefinitionStatisticsWithHttpInfo($failed_jobs, $incidents, $incidents_for_type, $root_incidents);
        return $response;
    }

    /**
     * Operation getProcessDefinitionStatisticsWithHttpInfo
     *
     * Get Process Instance Statistics
     *
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  bool $root_incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionStatisticsResultDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionStatisticsWithHttpInfo($failed_jobs = null, $incidents = null, $incidents_for_type = null, $root_incidents = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionStatisticsResultDto[]';
        $request = $this->getProcessDefinitionStatisticsRequest($failed_jobs, $incidents, $incidents_for_type, $root_incidents);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionStatisticsResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionStatisticsAsync
     *
     * Get Process Instance Statistics
     *
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  bool $root_incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionStatisticsAsync($failed_jobs = null, $incidents = null, $incidents_for_type = null, $root_incidents = null)
    {
        return $this->getProcessDefinitionStatisticsAsyncWithHttpInfo($failed_jobs, $incidents, $incidents_for_type, $root_incidents)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionStatisticsAsyncWithHttpInfo
     *
     * Get Process Instance Statistics
     *
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  bool $root_incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionStatisticsAsyncWithHttpInfo($failed_jobs = null, $incidents = null, $incidents_for_type = null, $root_incidents = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionStatisticsResultDto[]';
        $request = $this->getProcessDefinitionStatisticsRequest($failed_jobs, $incidents, $incidents_for_type, $root_incidents);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionStatistics'
     *
     * @param  bool $failed_jobs Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;. (optional)
     * @param  bool $incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;. (optional)
     * @param  string $incidents_for_type If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  bool $root_incidents Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionStatisticsRequest($failed_jobs = null, $incidents = null, $incidents_for_type = null, $root_incidents = null)
    {

        $resourcePath = '/process-definition/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($failed_jobs !== null) {
            $queryParams['failedJobs'] = ObjectSerializer::toQueryValue($failed_jobs, null);
        }
        // query params
        if ($incidents !== null) {
            $queryParams['incidents'] = ObjectSerializer::toQueryValue($incidents, null);
        }
        // query params
        if ($incidents_for_type !== null) {
            $queryParams['incidentsForType'] = ObjectSerializer::toQueryValue($incidents_for_type, null);
        }
        // query params
        if ($root_incidents !== null) {
            $queryParams['rootIncidents'] = ObjectSerializer::toQueryValue($root_incidents, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitions
     *
     * Get List
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessDefinitionDto[]
     */
    public function getProcessDefinitions($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->getProcessDefinitionsWithHttpInfo($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check, $sort_by, $sort_order, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation getProcessDefinitionsWithHttpInfo
     *
     * Get List
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessDefinitionDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionsWithHttpInfo($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto[]';
        $request = $this->getProcessDefinitionsRequest($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check, $sort_by, $sort_order, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessDefinitionDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionsAsync
     *
     * Get List
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionsAsync($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        return $this->getProcessDefinitionsAsyncWithHttpInfo($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check, $sort_by, $sort_order, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionsAsyncWithHttpInfo
     *
     * Get List
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionsAsyncWithHttpInfo($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessDefinitionDto[]';
        $request = $this->getProcessDefinitionsRequest($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check, $sort_by, $sort_order, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitions'
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionsRequest($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/process-definition';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_id_in !== null) {
            $queryParams['processDefinitionIdIn'] = ObjectSerializer::toQueryValue($process_definition_id_in, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($name_like !== null) {
            $queryParams['nameLike'] = ObjectSerializer::toQueryValue($name_like, null);
        }
        // query params
        if ($deployment_id !== null) {
            $queryParams['deploymentId'] = ObjectSerializer::toQueryValue($deployment_id, null);
        }
        // query params
        if ($deployed_after !== null) {
            $queryParams['deployedAfter'] = ObjectSerializer::toQueryValue($deployed_after, 'date-time');
        }
        // query params
        if ($deployed_at !== null) {
            $queryParams['deployedAt'] = ObjectSerializer::toQueryValue($deployed_at, 'date-time');
        }
        // query params
        if ($key !== null) {
            $queryParams['key'] = ObjectSerializer::toQueryValue($key, null);
        }
        // query params
        if ($keys_in !== null) {
            $queryParams['keysIn'] = ObjectSerializer::toQueryValue($keys_in, null);
        }
        // query params
        if ($key_like !== null) {
            $queryParams['keyLike'] = ObjectSerializer::toQueryValue($key_like, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($category_like !== null) {
            $queryParams['categoryLike'] = ObjectSerializer::toQueryValue($category_like, null);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version, 'int32');
        }
        // query params
        if ($latest_version !== null) {
            $queryParams['latestVersion'] = ObjectSerializer::toQueryValue($latest_version, null);
        }
        // query params
        if ($resource_name !== null) {
            $queryParams['resourceName'] = ObjectSerializer::toQueryValue($resource_name, null);
        }
        // query params
        if ($resource_name_like !== null) {
            $queryParams['resourceNameLike'] = ObjectSerializer::toQueryValue($resource_name_like, null);
        }
        // query params
        if ($startable_by !== null) {
            $queryParams['startableBy'] = ObjectSerializer::toQueryValue($startable_by, null);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active, null);
        }
        // query params
        if ($suspended !== null) {
            $queryParams['suspended'] = ObjectSerializer::toQueryValue($suspended, null);
        }
        // query params
        if ($incident_id !== null) {
            $queryParams['incidentId'] = ObjectSerializer::toQueryValue($incident_id, null);
        }
        // query params
        if ($incident_type !== null) {
            $queryParams['incidentType'] = ObjectSerializer::toQueryValue($incident_type, null);
        }
        // query params
        if ($incident_message !== null) {
            $queryParams['incidentMessage'] = ObjectSerializer::toQueryValue($incident_message, null);
        }
        // query params
        if ($incident_message_like !== null) {
            $queryParams['incidentMessageLike'] = ObjectSerializer::toQueryValue($incident_message_like, null);
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($include_process_definitions_without_tenant_id !== null) {
            $queryParams['includeProcessDefinitionsWithoutTenantId'] = ObjectSerializer::toQueryValue($include_process_definitions_without_tenant_id, null);
        }
        // query params
        if ($version_tag !== null) {
            $queryParams['versionTag'] = ObjectSerializer::toQueryValue($version_tag, null);
        }
        // query params
        if ($version_tag_like !== null) {
            $queryParams['versionTagLike'] = ObjectSerializer::toQueryValue($version_tag_like, null);
        }
        // query params
        if ($without_version_tag !== null) {
            $queryParams['withoutVersionTag'] = ObjectSerializer::toQueryValue($without_version_tag, null);
        }
        // query params
        if ($startable_in_tasklist !== null) {
            $queryParams['startableInTasklist'] = ObjectSerializer::toQueryValue($startable_in_tasklist, null);
        }
        // query params
        if ($not_startable_in_tasklist !== null) {
            $queryParams['notStartableInTasklist'] = ObjectSerializer::toQueryValue($not_startable_in_tasklist, null);
        }
        // query params
        if ($startable_permission_check !== null) {
            $queryParams['startablePermissionCheck'] = ObjectSerializer::toQueryValue($startable_permission_check, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order, null);
        }
        // query params
        if ($first_result !== null) {
            $queryParams['firstResult'] = ObjectSerializer::toQueryValue($first_result, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessDefinitionsCount
     *
     * Get List Count
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\CountResultDto
     */
    public function getProcessDefinitionsCount($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null)
    {
        list($response) = $this->getProcessDefinitionsCountWithHttpInfo($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check);
        return $response;
    }

    /**
     * Operation getProcessDefinitionsCountWithHttpInfo
     *
     * Get List Count
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\CountResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessDefinitionsCountWithHttpInfo($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null)
    {
        $returnType = '\Camunda\Client\Model\CountResultDto';
        $request = $this->getProcessDefinitionsCountRequest($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessDefinitionsCountAsync
     *
     * Get List Count
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionsCountAsync($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null)
    {
        return $this->getProcessDefinitionsCountAsyncWithHttpInfo($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessDefinitionsCountAsyncWithHttpInfo
     *
     * Get List Count
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessDefinitionsCountAsyncWithHttpInfo($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null)
    {
        $returnType = '\Camunda\Client\Model\CountResultDto';
        $request = $this->getProcessDefinitionsCountRequest($process_definition_id, $process_definition_id_in, $name, $name_like, $deployment_id, $deployed_after, $deployed_at, $key, $keys_in, $key_like, $category, $category_like, $version, $latest_version, $resource_name, $resource_name_like, $startable_by, $active, $suspended, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $include_process_definitions_without_tenant_id, $version_tag, $version_tag_like, $without_version_tag, $startable_in_tasklist, $not_startable_in_tasklist, $startable_permission_check);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessDefinitionsCount'
     *
     * @param  string $process_definition_id Filter by process definition id. (optional)
     * @param  string $process_definition_id_in Filter by a comma-separated list of process definition ids. (optional)
     * @param  string $name Filter by process definition name. (optional)
     * @param  string $name_like Filter by process definition names that the parameter is a substring of. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  \DateTime $deployed_after Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  \DateTime $deployed_at Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $key Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match. (optional)
     * @param  string $keys_in Filter by a comma-separated list of process definition keys. (optional)
     * @param  string $key_like Filter by process definition keys that the parameter is a substring of. (optional)
     * @param  string $category Filter by process definition category. Exact match. (optional)
     * @param  string $category_like Filter by process definition categories that the parameter is a substring of. (optional)
     * @param  int $version Filter by process definition version. (optional)
     * @param  bool $latest_version Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $resource_name Filter by the name of the process definition resource. Exact match. (optional)
     * @param  string $resource_name_like Filter by names of those process definition resources that the parameter is a substring of. (optional)
     * @param  string $startable_by Filter by a user name who is allowed to start the process. (optional)
     * @param  bool $active Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  bool $suspended Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior. (optional)
     * @param  bool $include_process_definitions_without_tenant_id Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional)
     * @param  string $version_tag Filter by the version tag. (optional)
     * @param  string $version_tag_like Filter by the version tag that the parameter is a substring of. (optional)
     * @param  bool $without_version_tag Only include process definitions without a &#x60;versionTag&#x60;. (optional)
     * @param  bool $startable_in_tasklist Filter by process definitions which are startable in Tasklist.. (optional)
     * @param  bool $not_startable_in_tasklist Filter by process definitions which are not startable in Tasklist. (optional)
     * @param  bool $startable_permission_check Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessDefinitionsCountRequest($process_definition_id = null, $process_definition_id_in = null, $name = null, $name_like = null, $deployment_id = null, $deployed_after = null, $deployed_at = null, $key = null, $keys_in = null, $key_like = null, $category = null, $category_like = null, $version = null, $latest_version = null, $resource_name = null, $resource_name_like = null, $startable_by = null, $active = null, $suspended = null, $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = null, $include_process_definitions_without_tenant_id = null, $version_tag = null, $version_tag_like = null, $without_version_tag = null, $startable_in_tasklist = null, $not_startable_in_tasklist = null, $startable_permission_check = null)
    {

        $resourcePath = '/process-definition/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_id_in !== null) {
            $queryParams['processDefinitionIdIn'] = ObjectSerializer::toQueryValue($process_definition_id_in, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($name_like !== null) {
            $queryParams['nameLike'] = ObjectSerializer::toQueryValue($name_like, null);
        }
        // query params
        if ($deployment_id !== null) {
            $queryParams['deploymentId'] = ObjectSerializer::toQueryValue($deployment_id, null);
        }
        // query params
        if ($deployed_after !== null) {
            $queryParams['deployedAfter'] = ObjectSerializer::toQueryValue($deployed_after, 'date-time');
        }
        // query params
        if ($deployed_at !== null) {
            $queryParams['deployedAt'] = ObjectSerializer::toQueryValue($deployed_at, 'date-time');
        }
        // query params
        if ($key !== null) {
            $queryParams['key'] = ObjectSerializer::toQueryValue($key, null);
        }
        // query params
        if ($keys_in !== null) {
            $queryParams['keysIn'] = ObjectSerializer::toQueryValue($keys_in, null);
        }
        // query params
        if ($key_like !== null) {
            $queryParams['keyLike'] = ObjectSerializer::toQueryValue($key_like, null);
        }
        // query params
        if ($category !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($category, null);
        }
        // query params
        if ($category_like !== null) {
            $queryParams['categoryLike'] = ObjectSerializer::toQueryValue($category_like, null);
        }
        // query params
        if ($version !== null) {
            $queryParams['version'] = ObjectSerializer::toQueryValue($version, 'int32');
        }
        // query params
        if ($latest_version !== null) {
            $queryParams['latestVersion'] = ObjectSerializer::toQueryValue($latest_version, null);
        }
        // query params
        if ($resource_name !== null) {
            $queryParams['resourceName'] = ObjectSerializer::toQueryValue($resource_name, null);
        }
        // query params
        if ($resource_name_like !== null) {
            $queryParams['resourceNameLike'] = ObjectSerializer::toQueryValue($resource_name_like, null);
        }
        // query params
        if ($startable_by !== null) {
            $queryParams['startableBy'] = ObjectSerializer::toQueryValue($startable_by, null);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active, null);
        }
        // query params
        if ($suspended !== null) {
            $queryParams['suspended'] = ObjectSerializer::toQueryValue($suspended, null);
        }
        // query params
        if ($incident_id !== null) {
            $queryParams['incidentId'] = ObjectSerializer::toQueryValue($incident_id, null);
        }
        // query params
        if ($incident_type !== null) {
            $queryParams['incidentType'] = ObjectSerializer::toQueryValue($incident_type, null);
        }
        // query params
        if ($incident_message !== null) {
            $queryParams['incidentMessage'] = ObjectSerializer::toQueryValue($incident_message, null);
        }
        // query params
        if ($incident_message_like !== null) {
            $queryParams['incidentMessageLike'] = ObjectSerializer::toQueryValue($incident_message_like, null);
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($include_process_definitions_without_tenant_id !== null) {
            $queryParams['includeProcessDefinitionsWithoutTenantId'] = ObjectSerializer::toQueryValue($include_process_definitions_without_tenant_id, null);
        }
        // query params
        if ($version_tag !== null) {
            $queryParams['versionTag'] = ObjectSerializer::toQueryValue($version_tag, null);
        }
        // query params
        if ($version_tag_like !== null) {
            $queryParams['versionTagLike'] = ObjectSerializer::toQueryValue($version_tag_like, null);
        }
        // query params
        if ($without_version_tag !== null) {
            $queryParams['withoutVersionTag'] = ObjectSerializer::toQueryValue($without_version_tag, null);
        }
        // query params
        if ($startable_in_tasklist !== null) {
            $queryParams['startableInTasklist'] = ObjectSerializer::toQueryValue($startable_in_tasklist, null);
        }
        // query params
        if ($not_startable_in_tasklist !== null) {
            $queryParams['notStartableInTasklist'] = ObjectSerializer::toQueryValue($not_startable_in_tasklist, null);
        }
        // query params
        if ($startable_permission_check !== null) {
            $queryParams['startablePermissionCheck'] = ObjectSerializer::toQueryValue($startable_permission_check, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRenderedStartForm
     *
     * Get Rendered Start Form
     *
     * @param  string $id The id of the process definition to get the rendered start form for. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getRenderedStartForm($id)
    {
        list($response) = $this->getRenderedStartFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRenderedStartFormWithHttpInfo
     *
     * Get Rendered Start Form
     *
     * @param  string $id The id of the process definition to get the rendered start form for. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRenderedStartFormWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getRenderedStartFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRenderedStartFormAsync
     *
     * Get Rendered Start Form
     *
     * @param  string $id The id of the process definition to get the rendered start form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedStartFormAsync($id)
    {
        return $this->getRenderedStartFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRenderedStartFormAsyncWithHttpInfo
     *
     * Get Rendered Start Form
     *
     * @param  string $id The id of the process definition to get the rendered start form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedStartFormAsyncWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getRenderedStartFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRenderedStartForm'
     *
     * @param  string $id The id of the process definition to get the rendered start form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRenderedStartFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRenderedStartForm'
            );
        }

        $resourcePath = '/process-definition/{id}/rendered-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRenderedStartFormByKey
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getRenderedStartFormByKey($key)
    {
        list($response) = $this->getRenderedStartFormByKeyWithHttpInfo($key);
        return $response;
    }

    /**
     * Operation getRenderedStartFormByKeyWithHttpInfo
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRenderedStartFormByKeyWithHttpInfo($key)
    {
        $returnType = 'string';
        $request = $this->getRenderedStartFormByKeyRequest($key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRenderedStartFormByKeyAsync
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedStartFormByKeyAsync($key)
    {
        return $this->getRenderedStartFormByKeyAsyncWithHttpInfo($key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRenderedStartFormByKeyAsyncWithHttpInfo
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedStartFormByKeyAsyncWithHttpInfo($key)
    {
        $returnType = 'string';
        $request = $this->getRenderedStartFormByKeyRequest($key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRenderedStartFormByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRenderedStartFormByKeyRequest($key)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getRenderedStartFormByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/rendered-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRenderedStartFormByKeyAndTenantId
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getRenderedStartFormByKeyAndTenantId($key, $tenant_id)
    {
        list($response) = $this->getRenderedStartFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id);
        return $response;
    }

    /**
     * Operation getRenderedStartFormByKeyAndTenantIdWithHttpInfo
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRenderedStartFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id)
    {
        $returnType = 'string';
        $request = $this->getRenderedStartFormByKeyAndTenantIdRequest($key, $tenant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRenderedStartFormByKeyAndTenantIdAsync
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedStartFormByKeyAndTenantIdAsync($key, $tenant_id)
    {
        return $this->getRenderedStartFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRenderedStartFormByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Get Rendered Start Form
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedStartFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
    {
        $returnType = 'string';
        $request = $this->getRenderedStartFormByKeyAndTenantIdRequest($key, $tenant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRenderedStartFormByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRenderedStartFormByKeyAndTenantIdRequest($key, $tenant_id)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getRenderedStartFormByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getRenderedStartFormByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/rendered-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartForm
     *
     * Get Start Form Key
     *
     * @param  string $id The id of the process definition to get the start form key for. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\FormDto
     */
    public function getStartForm($id)
    {
        list($response) = $this->getStartFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getStartFormWithHttpInfo
     *
     * Get Start Form Key
     *
     * @param  string $id The id of the process definition to get the start form key for. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\FormDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartFormWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\FormDto';
        $request = $this->getStartFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\FormDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartFormAsync
     *
     * Get Start Form Key
     *
     * @param  string $id The id of the process definition to get the start form key for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormAsync($id)
    {
        return $this->getStartFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartFormAsyncWithHttpInfo
     *
     * Get Start Form Key
     *
     * @param  string $id The id of the process definition to get the start form key for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormAsyncWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\FormDto';
        $request = $this->getStartFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartForm'
     *
     * @param  string $id The id of the process definition to get the start form key for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getStartForm'
            );
        }

        $resourcePath = '/process-definition/{id}/startForm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartFormByKey
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\FormDto
     */
    public function getStartFormByKey($key)
    {
        list($response) = $this->getStartFormByKeyWithHttpInfo($key);
        return $response;
    }

    /**
     * Operation getStartFormByKeyWithHttpInfo
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\FormDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartFormByKeyWithHttpInfo($key)
    {
        $returnType = '\Camunda\Client\Model\FormDto';
        $request = $this->getStartFormByKeyRequest($key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\FormDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartFormByKeyAsync
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormByKeyAsync($key)
    {
        return $this->getStartFormByKeyAsyncWithHttpInfo($key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartFormByKeyAsyncWithHttpInfo
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormByKeyAsyncWithHttpInfo($key)
    {
        $returnType = '\Camunda\Client\Model\FormDto';
        $request = $this->getStartFormByKeyRequest($key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartFormByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartFormByKeyRequest($key)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getStartFormByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/startForm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartFormByKeyAndTenantId
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\FormDto
     */
    public function getStartFormByKeyAndTenantId($key, $tenant_id)
    {
        list($response) = $this->getStartFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id);
        return $response;
    }

    /**
     * Operation getStartFormByKeyAndTenantIdWithHttpInfo
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\FormDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id)
    {
        $returnType = '\Camunda\Client\Model\FormDto';
        $request = $this->getStartFormByKeyAndTenantIdRequest($key, $tenant_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\FormDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartFormByKeyAndTenantIdAsync
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormByKeyAndTenantIdAsync($key, $tenant_id)
    {
        return $this->getStartFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartFormByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Get Start Form Key
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id)
    {
        $returnType = '\Camunda\Client\Model\FormDto';
        $request = $this->getStartFormByKeyAndTenantIdRequest($key, $tenant_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartFormByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) for which the form key is to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartFormByKeyAndTenantIdRequest($key, $tenant_id)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getStartFormByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getStartFormByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/startForm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartFormVariables
     *
     * Get Start Form Variables
     *
     * @param  string $id The id of the process definition to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Camunda\Client\Model\VariableValueDto]
     */
    public function getStartFormVariables($id, $variable_names = null, $deserialize_values = 'true')
    {
        list($response) = $this->getStartFormVariablesWithHttpInfo($id, $variable_names, $deserialize_values);
        return $response;
    }

    /**
     * Operation getStartFormVariablesWithHttpInfo
     *
     * Get Start Form Variables
     *
     * @param  string $id The id of the process definition to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Camunda\Client\Model\VariableValueDto], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartFormVariablesWithHttpInfo($id, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Camunda\Client\Model\VariableValueDto]';
        $request = $this->getStartFormVariablesRequest($id, $variable_names, $deserialize_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Camunda\Client\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartFormVariablesAsync
     *
     * Get Start Form Variables
     *
     * @param  string $id The id of the process definition to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormVariablesAsync($id, $variable_names = null, $deserialize_values = 'true')
    {
        return $this->getStartFormVariablesAsyncWithHttpInfo($id, $variable_names, $deserialize_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartFormVariablesAsyncWithHttpInfo
     *
     * Get Start Form Variables
     *
     * @param  string $id The id of the process definition to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormVariablesAsyncWithHttpInfo($id, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Camunda\Client\Model\VariableValueDto]';
        $request = $this->getStartFormVariablesRequest($id, $variable_names, $deserialize_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartFormVariables'
     *
     * @param  string $id The id of the process definition to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartFormVariablesRequest($id, $variable_names = null, $deserialize_values = 'true')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getStartFormVariables'
            );
        }

        $resourcePath = '/process-definition/{id}/form-variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variable_names !== null) {
            $queryParams['variableNames'] = ObjectSerializer::toQueryValue($variable_names, null);
        }
        // query params
        if ($deserialize_values !== null) {
            $queryParams['deserializeValues'] = ObjectSerializer::toQueryValue($deserialize_values, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartFormVariablesByKey
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Camunda\Client\Model\VariableValueDto]
     */
    public function getStartFormVariablesByKey($key, $variable_names = null, $deserialize_values = 'true')
    {
        list($response) = $this->getStartFormVariablesByKeyWithHttpInfo($key, $variable_names, $deserialize_values);
        return $response;
    }

    /**
     * Operation getStartFormVariablesByKeyWithHttpInfo
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Camunda\Client\Model\VariableValueDto], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartFormVariablesByKeyWithHttpInfo($key, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Camunda\Client\Model\VariableValueDto]';
        $request = $this->getStartFormVariablesByKeyRequest($key, $variable_names, $deserialize_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Camunda\Client\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartFormVariablesByKeyAsync
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormVariablesByKeyAsync($key, $variable_names = null, $deserialize_values = 'true')
    {
        return $this->getStartFormVariablesByKeyAsyncWithHttpInfo($key, $variable_names, $deserialize_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartFormVariablesByKeyAsyncWithHttpInfo
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormVariablesByKeyAsyncWithHttpInfo($key, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Camunda\Client\Model\VariableValueDto]';
        $request = $this->getStartFormVariablesByKeyRequest($key, $variable_names, $deserialize_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartFormVariablesByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartFormVariablesByKeyRequest($key, $variable_names = null, $deserialize_values = 'true')
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getStartFormVariablesByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/form-variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variable_names !== null) {
            $queryParams['variableNames'] = ObjectSerializer::toQueryValue($variable_names, null);
        }
        // query params
        if ($deserialize_values !== null) {
            $queryParams['deserializeValues'] = ObjectSerializer::toQueryValue($deserialize_values, null);
        }

        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStartFormVariablesByKeyAndTenantId
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Camunda\Client\Model\VariableValueDto]
     */
    public function getStartFormVariablesByKeyAndTenantId($key, $tenant_id, $variable_names = null, $deserialize_values = 'true')
    {
        list($response) = $this->getStartFormVariablesByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $variable_names, $deserialize_values);
        return $response;
    }

    /**
     * Operation getStartFormVariablesByKeyAndTenantIdWithHttpInfo
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Camunda\Client\Model\VariableValueDto], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStartFormVariablesByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Camunda\Client\Model\VariableValueDto]';
        $request = $this->getStartFormVariablesByKeyAndTenantIdRequest($key, $tenant_id, $variable_names, $deserialize_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Camunda\Client\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStartFormVariablesByKeyAndTenantIdAsync
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormVariablesByKeyAndTenantIdAsync($key, $tenant_id, $variable_names = null, $deserialize_values = 'true')
    {
        return $this->getStartFormVariablesByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $variable_names, $deserialize_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStartFormVariablesByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Get Start Form Variables
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStartFormVariablesByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Camunda\Client\Model\VariableValueDto]';
        $request = $this->getStartFormVariablesByKeyAndTenantIdRequest($key, $tenant_id, $variable_names, $deserialize_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStartFormVariablesByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStartFormVariablesByKeyAndTenantIdRequest($key, $tenant_id, $variable_names = null, $deserialize_values = 'true')
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling getStartFormVariablesByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling getStartFormVariablesByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/form-variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variable_names !== null) {
            $queryParams['variableNames'] = ObjectSerializer::toQueryValue($variable_names, null);
        }
        // query params
        if ($deserialize_values !== null) {
            $queryParams['deserializeValues'] = ObjectSerializer::toQueryValue($deserialize_values, null);
        }

        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStaticCalledProcessDefinitions
     *
     * Get Static Called Process Definitions
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\CalledProcessDefinitionDto[]
     */
    public function getStaticCalledProcessDefinitions($id)
    {
        list($response) = $this->getStaticCalledProcessDefinitionsWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getStaticCalledProcessDefinitionsWithHttpInfo
     *
     * Get Static Called Process Definitions
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\CalledProcessDefinitionDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getStaticCalledProcessDefinitionsWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\CalledProcessDefinitionDto[]';
        $request = $this->getStaticCalledProcessDefinitionsRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\CalledProcessDefinitionDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getStaticCalledProcessDefinitionsAsync
     *
     * Get Static Called Process Definitions
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStaticCalledProcessDefinitionsAsync($id)
    {
        return $this->getStaticCalledProcessDefinitionsAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStaticCalledProcessDefinitionsAsyncWithHttpInfo
     *
     * Get Static Called Process Definitions
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStaticCalledProcessDefinitionsAsyncWithHttpInfo($id)
    {
        $returnType = '\Camunda\Client\Model\CalledProcessDefinitionDto[]';
        $request = $this->getStaticCalledProcessDefinitionsRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStaticCalledProcessDefinitions'
     *
     * @param  string $id The id of the process definition. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getStaticCalledProcessDefinitionsRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getStaticCalledProcessDefinitions'
            );
        }

        $resourcePath = '/process-definition/{id}/static-called-process-definitions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restartProcessInstance
     *
     * Restart Process Instance
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function restartProcessInstance($id, $body = null)
    {
        $this->restartProcessInstanceWithHttpInfo($id, $body);
    }

    /**
     * Operation restartProcessInstanceWithHttpInfo
     *
     * Restart Process Instance
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function restartProcessInstanceWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->restartProcessInstanceRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restartProcessInstanceAsync
     *
     * Restart Process Instance
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restartProcessInstanceAsync($id, $body = null)
    {
        return $this->restartProcessInstanceAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restartProcessInstanceAsyncWithHttpInfo
     *
     * Restart Process Instance
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restartProcessInstanceAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->restartProcessInstanceRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restartProcessInstance'
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restartProcessInstanceRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restartProcessInstance'
            );
        }

        $resourcePath = '/process-definition/{id}/restart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restartProcessInstanceAsyncOperation
     *
     * Restart Process Instance Async
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\BatchDto
     */
    public function restartProcessInstanceAsyncOperation($id, $body = null)
    {
        list($response) = $this->restartProcessInstanceAsyncOperationWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation restartProcessInstanceAsyncOperationWithHttpInfo
     *
     * Restart Process Instance Async
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function restartProcessInstanceAsyncOperationWithHttpInfo($id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\BatchDto';
        $request = $this->restartProcessInstanceAsyncOperationRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restartProcessInstanceAsyncOperationAsync
     *
     * Restart Process Instance Async
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restartProcessInstanceAsyncOperationAsync($id, $body = null)
    {
        return $this->restartProcessInstanceAsyncOperationAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restartProcessInstanceAsyncOperationAsyncWithHttpInfo
     *
     * Restart Process Instance Async
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restartProcessInstanceAsyncOperationAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\BatchDto';
        $request = $this->restartProcessInstanceAsyncOperationRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restartProcessInstanceAsyncOperation'
     *
     * @param  string $id The id of the process definition of the process instances to restart. (required)
     * @param  \Camunda\Client\Model\RestartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function restartProcessInstanceAsyncOperationRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restartProcessInstanceAsyncOperation'
            );
        }

        $resourcePath = '/process-definition/{id}/restart-async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startProcessInstance
     *
     * Start Instance
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessInstanceWithVariablesDto
     */
    public function startProcessInstance($id, $body = null)
    {
        list($response) = $this->startProcessInstanceWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation startProcessInstanceWithHttpInfo
     *
     * Start Instance
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessInstanceWithVariablesDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function startProcessInstanceWithHttpInfo($id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceWithVariablesDto';
        $request = $this->startProcessInstanceRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessInstanceWithVariablesDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startProcessInstanceAsync
     *
     * Start Instance
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startProcessInstanceAsync($id, $body = null)
    {
        return $this->startProcessInstanceAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startProcessInstanceAsyncWithHttpInfo
     *
     * Start Instance
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startProcessInstanceAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceWithVariablesDto';
        $request = $this->startProcessInstanceRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startProcessInstance'
     *
     * @param  string $id The id of the process definition to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startProcessInstanceRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling startProcessInstance'
            );
        }

        $resourcePath = '/process-definition/{id}/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startProcessInstanceByKey
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessInstanceWithVariablesDto
     */
    public function startProcessInstanceByKey($key, $body = null)
    {
        list($response) = $this->startProcessInstanceByKeyWithHttpInfo($key, $body);
        return $response;
    }

    /**
     * Operation startProcessInstanceByKeyWithHttpInfo
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessInstanceWithVariablesDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function startProcessInstanceByKeyWithHttpInfo($key, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceWithVariablesDto';
        $request = $this->startProcessInstanceByKeyRequest($key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessInstanceWithVariablesDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startProcessInstanceByKeyAsync
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startProcessInstanceByKeyAsync($key, $body = null)
    {
        return $this->startProcessInstanceByKeyAsyncWithHttpInfo($key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startProcessInstanceByKeyAsyncWithHttpInfo
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startProcessInstanceByKeyAsyncWithHttpInfo($key, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceWithVariablesDto';
        $request = $this->startProcessInstanceByKeyRequest($key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startProcessInstanceByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startProcessInstanceByKeyRequest($key, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling startProcessInstanceByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startProcessInstanceByKeyAndTenantId
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessInstanceWithVariablesDto
     */
    public function startProcessInstanceByKeyAndTenantId($key, $tenant_id, $body = null)
    {
        list($response) = $this->startProcessInstanceByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body);
        return $response;
    }

    /**
     * Operation startProcessInstanceByKeyAndTenantIdWithHttpInfo
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessInstanceWithVariablesDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function startProcessInstanceByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceWithVariablesDto';
        $request = $this->startProcessInstanceByKeyAndTenantIdRequest($key, $tenant_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessInstanceWithVariablesDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startProcessInstanceByKeyAndTenantIdAsync
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startProcessInstanceByKeyAndTenantIdAsync($key, $tenant_id, $body = null)
    {
        return $this->startProcessInstanceByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startProcessInstanceByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Start Instance
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startProcessInstanceByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceWithVariablesDto';
        $request = $this->startProcessInstanceByKeyAndTenantIdRequest($key, $tenant_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startProcessInstanceByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be retrieved. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startProcessInstanceByKeyAndTenantIdRequest($key, $tenant_id, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling startProcessInstanceByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling startProcessInstanceByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitForm
     *
     * Submit Start Form
     *
     * @param  string $id The id of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessInstanceDto
     */
    public function submitForm($id, $body = null)
    {
        list($response) = $this->submitFormWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation submitFormWithHttpInfo
     *
     * Submit Start Form
     *
     * @param  string $id The id of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessInstanceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitFormWithHttpInfo($id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceDto';
        $request = $this->submitFormRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessInstanceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitFormAsync
     *
     * Submit Start Form
     *
     * @param  string $id The id of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitFormAsync($id, $body = null)
    {
        return $this->submitFormAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitFormAsyncWithHttpInfo
     *
     * Submit Start Form
     *
     * @param  string $id The id of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitFormAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceDto';
        $request = $this->submitFormRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitForm'
     *
     * @param  string $id The id of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function submitFormRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling submitForm'
            );
        }

        $resourcePath = '/process-definition/{id}/submit-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitFormByKey
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessInstanceDto
     */
    public function submitFormByKey($key, $body = null)
    {
        list($response) = $this->submitFormByKeyWithHttpInfo($key, $body);
        return $response;
    }

    /**
     * Operation submitFormByKeyWithHttpInfo
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessInstanceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitFormByKeyWithHttpInfo($key, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceDto';
        $request = $this->submitFormByKeyRequest($key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessInstanceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitFormByKeyAsync
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitFormByKeyAsync($key, $body = null)
    {
        return $this->submitFormByKeyAsyncWithHttpInfo($key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitFormByKeyAsyncWithHttpInfo
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitFormByKeyAsyncWithHttpInfo($key, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceDto';
        $request = $this->submitFormByKeyRequest($key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitFormByKey'
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function submitFormByKeyRequest($key, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling submitFormByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/submit-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submitFormByKeyAndTenantId
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Camunda\Client\Model\ProcessInstanceDto
     */
    public function submitFormByKeyAndTenantId($key, $tenant_id, $body = null)
    {
        list($response) = $this->submitFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body);
        return $response;
    }

    /**
     * Operation submitFormByKeyAndTenantIdWithHttpInfo
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Camunda\Client\Model\ProcessInstanceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitFormByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceDto';
        $request = $this->submitFormByKeyAndTenantIdRequest($key, $tenant_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ProcessInstanceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitFormByKeyAndTenantIdAsync
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitFormByKeyAndTenantIdAsync($key, $tenant_id, $body = null)
    {
        return $this->submitFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitFormByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Submit Start Form
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitFormByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '\Camunda\Client\Model\ProcessInstanceDto';
        $request = $this->submitFormByKeyAndTenantIdRequest($key, $tenant_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submitFormByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition to submit the form for. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\StartProcessInstanceFormDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function submitFormByKeyAndTenantIdRequest($key, $tenant_id, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling submitFormByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling submitFormByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/submit-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionId
     *
     * Update History Time to Live
     *
     * @param  string $id The id of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateHistoryTimeToLiveByProcessDefinitionId($id, $body = null)
    {
        $this->updateHistoryTimeToLiveByProcessDefinitionIdWithHttpInfo($id, $body);
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionIdWithHttpInfo
     *
     * Update History Time to Live
     *
     * @param  string $id The id of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateHistoryTimeToLiveByProcessDefinitionIdWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateHistoryTimeToLiveByProcessDefinitionIdRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionIdAsync
     *
     * Update History Time to Live
     *
     * @param  string $id The id of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHistoryTimeToLiveByProcessDefinitionIdAsync($id, $body = null)
    {
        return $this->updateHistoryTimeToLiveByProcessDefinitionIdAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionIdAsyncWithHttpInfo
     *
     * Update History Time to Live
     *
     * @param  string $id The id of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHistoryTimeToLiveByProcessDefinitionIdAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateHistoryTimeToLiveByProcessDefinitionIdRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateHistoryTimeToLiveByProcessDefinitionId'
     *
     * @param  string $id The id of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateHistoryTimeToLiveByProcessDefinitionIdRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateHistoryTimeToLiveByProcessDefinitionId'
            );
        }

        $resourcePath = '/process-definition/{id}/history-time-to-live';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKey
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKey($key, $body = null)
    {
        $this->updateHistoryTimeToLiveByProcessDefinitionKeyWithHttpInfo($key, $body);
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKeyWithHttpInfo
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKeyWithHttpInfo($key, $body = null)
    {
        $returnType = '';
        $request = $this->updateHistoryTimeToLiveByProcessDefinitionKeyRequest($key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKeyAsync
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKeyAsync($key, $body = null)
    {
        return $this->updateHistoryTimeToLiveByProcessDefinitionKeyAsyncWithHttpInfo($key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKeyAsyncWithHttpInfo
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKeyAsyncWithHttpInfo($key, $body = null)
    {
        $returnType = '';
        $request = $this->updateHistoryTimeToLiveByProcessDefinitionKeyRequest($key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateHistoryTimeToLiveByProcessDefinitionKey'
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateHistoryTimeToLiveByProcessDefinitionKeyRequest($key, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling updateHistoryTimeToLiveByProcessDefinitionKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/history-time-to-live';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId($key, $tenant_id, $body = null)
    {
        $this->updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body);
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdWithHttpInfo
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '';
        $request = $this->updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest($key, $tenant_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdAsync
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdAsync($key, $tenant_id, $body = null)
    {
        return $this->updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdAsyncWithHttpInfo
     *
     * Update History Time to Live
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '';
        $request = $this->updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest($key, $tenant_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId'
     *
     * @param  string $key The key of the process definition to change history time to live. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\HistoryTimeToLiveDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantIdRequest($key, $tenant_id, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/history-time-to-live';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProcessDefinitionSuspensionState
     *
     * Activate/Suspend By Key
     *
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed property is &#x60;processDefinitionId&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateProcessDefinitionSuspensionState($body = null)
    {
        $this->updateProcessDefinitionSuspensionStateWithHttpInfo($body);
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateWithHttpInfo
     *
     * Activate/Suspend By Key
     *
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed property is &#x60;processDefinitionId&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProcessDefinitionSuspensionStateWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateAsync
     *
     * Activate/Suspend By Key
     *
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed property is &#x60;processDefinitionId&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateAsync($body = null)
    {
        return $this->updateProcessDefinitionSuspensionStateAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateAsyncWithHttpInfo
     *
     * Activate/Suspend By Key
     *
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed property is &#x60;processDefinitionId&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProcessDefinitionSuspensionState'
     *
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed property is &#x60;processDefinitionId&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateProcessDefinitionSuspensionStateRequest($body = null)
    {

        $resourcePath = '/process-definition/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateById
     *
     * Activate/Suspend By Id
     *
     * @param  string $id The id of the process definition to activate or suspend. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateProcessDefinitionSuspensionStateById($id, $body = null)
    {
        $this->updateProcessDefinitionSuspensionStateByIdWithHttpInfo($id, $body);
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByIdWithHttpInfo
     *
     * Activate/Suspend By Id
     *
     * @param  string $id The id of the process definition to activate or suspend. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProcessDefinitionSuspensionStateByIdWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateByIdRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByIdAsync
     *
     * Activate/Suspend By Id
     *
     * @param  string $id The id of the process definition to activate or suspend. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateByIdAsync($id, $body = null)
    {
        return $this->updateProcessDefinitionSuspensionStateByIdAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByIdAsyncWithHttpInfo
     *
     * Activate/Suspend By Id
     *
     * @param  string $id The id of the process definition to activate or suspend. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateByIdAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateByIdRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProcessDefinitionSuspensionStateById'
     *
     * @param  string $id The id of the process definition to activate or suspend. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateProcessDefinitionSuspensionStateByIdRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateProcessDefinitionSuspensionStateById'
            );
        }

        $resourcePath = '/process-definition/{id}/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKey
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateProcessDefinitionSuspensionStateByKey($key, $body = null)
    {
        $this->updateProcessDefinitionSuspensionStateByKeyWithHttpInfo($key, $body);
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKeyWithHttpInfo
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProcessDefinitionSuspensionStateByKeyWithHttpInfo($key, $body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateByKeyRequest($key, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKeyAsync
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateByKeyAsync($key, $body = null)
    {
        return $this->updateProcessDefinitionSuspensionStateByKeyAsyncWithHttpInfo($key, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKeyAsyncWithHttpInfo
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateByKeyAsyncWithHttpInfo($key, $body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateByKeyRequest($key, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProcessDefinitionSuspensionStateByKey'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateProcessDefinitionSuspensionStateByKeyRequest($key, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling updateProcessDefinitionSuspensionStateByKey'
            );
        }

        $resourcePath = '/process-definition/key/{key}/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKeyAndTenantId
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateProcessDefinitionSuspensionStateByKeyAndTenantId($key, $tenant_id, $body = null)
    {
        $this->updateProcessDefinitionSuspensionStateByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body);
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKeyAndTenantIdWithHttpInfo
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \Camunda\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateProcessDefinitionSuspensionStateByKeyAndTenantIdWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest($key, $tenant_id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Camunda\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKeyAndTenantIdAsync
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateByKeyAndTenantIdAsync($key, $tenant_id, $body = null)
    {
        return $this->updateProcessDefinitionSuspensionStateByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateProcessDefinitionSuspensionStateByKeyAndTenantIdAsyncWithHttpInfo
     *
     * Activate/Suspend by Id
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateProcessDefinitionSuspensionStateByKeyAndTenantIdAsyncWithHttpInfo($key, $tenant_id, $body = null)
    {
        $returnType = '';
        $request = $this->updateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest($key, $tenant_id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateProcessDefinitionSuspensionStateByKeyAndTenantId'
     *
     * @param  string $key The key of the process definition (the latest version thereof) to be activated/suspended. (required)
     * @param  string $tenant_id The id of the tenant the process definition belongs to. (required)
     * @param  \Camunda\Client\Model\ProcessDefinitionSuspensionStateDto $body **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateProcessDefinitionSuspensionStateByKeyAndTenantIdRequest($key, $tenant_id, $body = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId'
            );
        }
        // verify the required parameter 'tenant_id' is set
        if ($tenant_id === null || (is_array($tenant_id) && count($tenant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant_id when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId'
            );
        }

        $resourcePath = '/process-definition/key/{key}/tenant-id/{tenant-id}/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($key !== null) {
            $resourcePath = str_replace(
                '{' . 'key' . '}',
                ObjectSerializer::toPathValue($key),
                $resourcePath
            );
        }
        // path params
        if ($tenant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tenant-id' . '}',
                ObjectSerializer::toPathValue($tenant_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
