<?php
/**
 * ProcessInstanceApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.21.1-ee
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.56
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ProcessInstanceApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProcessInstanceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation correlateMessageAsyncOperation
     *
     * Correlate Message Async (POST)
     *
     * @param  \Swagger\Client\Model\CorrelationMessageAsyncDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function correlateMessageAsyncOperation($body = null)
    {
        list($response) = $this->correlateMessageAsyncOperationWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation correlateMessageAsyncOperationWithHttpInfo
     *
     * Correlate Message Async (POST)
     *
     * @param  \Swagger\Client\Model\CorrelationMessageAsyncDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function correlateMessageAsyncOperationWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->correlateMessageAsyncOperationRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation correlateMessageAsyncOperationAsync
     *
     * Correlate Message Async (POST)
     *
     * @param  \Swagger\Client\Model\CorrelationMessageAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function correlateMessageAsyncOperationAsync($body = null)
    {
        return $this->correlateMessageAsyncOperationAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation correlateMessageAsyncOperationAsyncWithHttpInfo
     *
     * Correlate Message Async (POST)
     *
     * @param  \Swagger\Client\Model\CorrelationMessageAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function correlateMessageAsyncOperationAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->correlateMessageAsyncOperationRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'correlateMessageAsyncOperation'
     *
     * @param  \Swagger\Client\Model\CorrelationMessageAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function correlateMessageAsyncOperationRequest($body = null)
    {

        $resourcePath = '/process-instance/message-async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAsyncHistoricQueryBased
     *
     * Delete Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function deleteAsyncHistoricQueryBased($body = null)
    {
        list($response) = $this->deleteAsyncHistoricQueryBasedWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation deleteAsyncHistoricQueryBasedWithHttpInfo
     *
     * Delete Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAsyncHistoricQueryBasedWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->deleteAsyncHistoricQueryBasedRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAsyncHistoricQueryBasedAsync
     *
     * Delete Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAsyncHistoricQueryBasedAsync($body = null)
    {
        return $this->deleteAsyncHistoricQueryBasedAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAsyncHistoricQueryBasedAsyncWithHttpInfo
     *
     * Delete Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAsyncHistoricQueryBasedAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->deleteAsyncHistoricQueryBasedRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAsyncHistoricQueryBased'
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAsyncHistoricQueryBasedRequest($body = null)
    {

        $resourcePath = '/process-instance/delete-historic-query-based';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProcessInstance
     *
     * Delete
     *
     * @param  string $id The id of the process instance to be deleted. (required)
     * @param  bool $skip_custom_listeners If set to true, the custom listeners will be skipped. (optional, default to false)
     * @param  bool $skip_io_mappings If set to true, the input/output mappings will be skipped. (optional, default to false)
     * @param  bool $skip_subprocesses If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)
     * @param  bool $fail_if_not_exists If set to false, the request will still be successful if the process id is not found. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProcessInstance($id, $skip_custom_listeners = 'false', $skip_io_mappings = 'false', $skip_subprocesses = 'false', $fail_if_not_exists = 'true')
    {
        $this->deleteProcessInstanceWithHttpInfo($id, $skip_custom_listeners, $skip_io_mappings, $skip_subprocesses, $fail_if_not_exists);
    }

    /**
     * Operation deleteProcessInstanceWithHttpInfo
     *
     * Delete
     *
     * @param  string $id The id of the process instance to be deleted. (required)
     * @param  bool $skip_custom_listeners If set to true, the custom listeners will be skipped. (optional, default to false)
     * @param  bool $skip_io_mappings If set to true, the input/output mappings will be skipped. (optional, default to false)
     * @param  bool $skip_subprocesses If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)
     * @param  bool $fail_if_not_exists If set to false, the request will still be successful if the process id is not found. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProcessInstanceWithHttpInfo($id, $skip_custom_listeners = 'false', $skip_io_mappings = 'false', $skip_subprocesses = 'false', $fail_if_not_exists = 'true')
    {
        $returnType = '';
        $request = $this->deleteProcessInstanceRequest($id, $skip_custom_listeners, $skip_io_mappings, $skip_subprocesses, $fail_if_not_exists);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProcessInstanceAsync
     *
     * Delete
     *
     * @param  string $id The id of the process instance to be deleted. (required)
     * @param  bool $skip_custom_listeners If set to true, the custom listeners will be skipped. (optional, default to false)
     * @param  bool $skip_io_mappings If set to true, the input/output mappings will be skipped. (optional, default to false)
     * @param  bool $skip_subprocesses If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)
     * @param  bool $fail_if_not_exists If set to false, the request will still be successful if the process id is not found. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessInstanceAsync($id, $skip_custom_listeners = 'false', $skip_io_mappings = 'false', $skip_subprocesses = 'false', $fail_if_not_exists = 'true')
    {
        return $this->deleteProcessInstanceAsyncWithHttpInfo($id, $skip_custom_listeners, $skip_io_mappings, $skip_subprocesses, $fail_if_not_exists)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProcessInstanceAsyncWithHttpInfo
     *
     * Delete
     *
     * @param  string $id The id of the process instance to be deleted. (required)
     * @param  bool $skip_custom_listeners If set to true, the custom listeners will be skipped. (optional, default to false)
     * @param  bool $skip_io_mappings If set to true, the input/output mappings will be skipped. (optional, default to false)
     * @param  bool $skip_subprocesses If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)
     * @param  bool $fail_if_not_exists If set to false, the request will still be successful if the process id is not found. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessInstanceAsyncWithHttpInfo($id, $skip_custom_listeners = 'false', $skip_io_mappings = 'false', $skip_subprocesses = 'false', $fail_if_not_exists = 'true')
    {
        $returnType = '';
        $request = $this->deleteProcessInstanceRequest($id, $skip_custom_listeners, $skip_io_mappings, $skip_subprocesses, $fail_if_not_exists);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProcessInstance'
     *
     * @param  string $id The id of the process instance to be deleted. (required)
     * @param  bool $skip_custom_listeners If set to true, the custom listeners will be skipped. (optional, default to false)
     * @param  bool $skip_io_mappings If set to true, the input/output mappings will be skipped. (optional, default to false)
     * @param  bool $skip_subprocesses If set to true, subprocesses related to deleted processes will be skipped. (optional, default to false)
     * @param  bool $fail_if_not_exists If set to false, the request will still be successful if the process id is not found. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProcessInstanceRequest($id, $skip_custom_listeners = 'false', $skip_io_mappings = 'false', $skip_subprocesses = 'false', $fail_if_not_exists = 'true')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteProcessInstance'
            );
        }

        $resourcePath = '/process-instance/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($skip_custom_listeners !== null) {
            $queryParams['skipCustomListeners'] = ObjectSerializer::toQueryValue($skip_custom_listeners, null);
        }
        // query params
        if ($skip_io_mappings !== null) {
            $queryParams['skipIoMappings'] = ObjectSerializer::toQueryValue($skip_io_mappings, null);
        }
        // query params
        if ($skip_subprocesses !== null) {
            $queryParams['skipSubprocesses'] = ObjectSerializer::toQueryValue($skip_subprocesses, null);
        }
        // query params
        if ($fail_if_not_exists !== null) {
            $queryParams['failIfNotExists'] = ObjectSerializer::toQueryValue($fail_if_not_exists, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProcessInstanceVariable
     *
     * Delete Process Variable
     *
     * @param  string $id The id of the process instance to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteProcessInstanceVariable($id, $var_name)
    {
        $this->deleteProcessInstanceVariableWithHttpInfo($id, $var_name);
    }

    /**
     * Operation deleteProcessInstanceVariableWithHttpInfo
     *
     * Delete Process Variable
     *
     * @param  string $id The id of the process instance to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProcessInstanceVariableWithHttpInfo($id, $var_name)
    {
        $returnType = '';
        $request = $this->deleteProcessInstanceVariableRequest($id, $var_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProcessInstanceVariableAsync
     *
     * Delete Process Variable
     *
     * @param  string $id The id of the process instance to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessInstanceVariableAsync($id, $var_name)
    {
        return $this->deleteProcessInstanceVariableAsyncWithHttpInfo($id, $var_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProcessInstanceVariableAsyncWithHttpInfo
     *
     * Delete Process Variable
     *
     * @param  string $id The id of the process instance to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessInstanceVariableAsyncWithHttpInfo($id, $var_name)
    {
        $returnType = '';
        $request = $this->deleteProcessInstanceVariableRequest($id, $var_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProcessInstanceVariable'
     *
     * @param  string $id The id of the process instance to delete the variable from. (required)
     * @param  string $var_name The name of the variable to delete. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProcessInstanceVariableRequest($id, $var_name)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteProcessInstanceVariable'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling deleteProcessInstanceVariable'
            );
        }

        $resourcePath = '/process-instance/{id}/variables/{varName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteProcessInstancesAsyncOperation
     *
     * Delete Async (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function deleteProcessInstancesAsyncOperation($body = null)
    {
        list($response) = $this->deleteProcessInstancesAsyncOperationWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation deleteProcessInstancesAsyncOperationWithHttpInfo
     *
     * Delete Async (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteProcessInstancesAsyncOperationWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->deleteProcessInstancesAsyncOperationRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteProcessInstancesAsyncOperationAsync
     *
     * Delete Async (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessInstancesAsyncOperationAsync($body = null)
    {
        return $this->deleteProcessInstancesAsyncOperationAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteProcessInstancesAsyncOperationAsyncWithHttpInfo
     *
     * Delete Async (POST)
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteProcessInstancesAsyncOperationAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->deleteProcessInstancesAsyncOperationRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteProcessInstancesAsyncOperation'
     *
     * @param  \Swagger\Client\Model\DeleteProcessInstancesDto $body **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteProcessInstancesAsyncOperationRequest($body = null)
    {

        $resourcePath = '/process-instance/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getActivityInstanceTree
     *
     * Get Activity Instance
     *
     * @param  string $id The id of the process instance for which the activity instance should be retrieved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ActivityInstanceDto
     */
    public function getActivityInstanceTree($id)
    {
        list($response) = $this->getActivityInstanceTreeWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getActivityInstanceTreeWithHttpInfo
     *
     * Get Activity Instance
     *
     * @param  string $id The id of the process instance for which the activity instance should be retrieved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ActivityInstanceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getActivityInstanceTreeWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\ActivityInstanceDto';
        $request = $this->getActivityInstanceTreeRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ActivityInstanceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getActivityInstanceTreeAsync
     *
     * Get Activity Instance
     *
     * @param  string $id The id of the process instance for which the activity instance should be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityInstanceTreeAsync($id)
    {
        return $this->getActivityInstanceTreeAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getActivityInstanceTreeAsyncWithHttpInfo
     *
     * Get Activity Instance
     *
     * @param  string $id The id of the process instance for which the activity instance should be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getActivityInstanceTreeAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\ActivityInstanceDto';
        $request = $this->getActivityInstanceTreeRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getActivityInstanceTree'
     *
     * @param  string $id The id of the process instance for which the activity instance should be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getActivityInstanceTreeRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getActivityInstanceTree'
            );
        }

        $resourcePath = '/process-instance/{id}/activity-instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessInstance
     *
     * Get Process Instance
     *
     * @param  string $id The id of the process instance to be retrieved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProcessInstanceDto
     */
    public function getProcessInstance($id)
    {
        list($response) = $this->getProcessInstanceWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProcessInstanceWithHttpInfo
     *
     * Get Process Instance
     *
     * @param  string $id The id of the process instance to be retrieved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProcessInstanceDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessInstanceWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\ProcessInstanceDto';
        $request = $this->getProcessInstanceRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProcessInstanceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessInstanceAsync
     *
     * Get Process Instance
     *
     * @param  string $id The id of the process instance to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceAsync($id)
    {
        return $this->getProcessInstanceAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessInstanceAsyncWithHttpInfo
     *
     * Get Process Instance
     *
     * @param  string $id The id of the process instance to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\ProcessInstanceDto';
        $request = $this->getProcessInstanceRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessInstance'
     *
     * @param  string $id The id of the process instance to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessInstanceRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessInstance'
            );
        }

        $resourcePath = '/process-instance/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessInstanceComments
     *
     * Get Process Instance Comments
     *
     * @param  string $id The id of the process instance to retrieve the comments for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CommentDto[]
     */
    public function getProcessInstanceComments($id)
    {
        list($response) = $this->getProcessInstanceCommentsWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getProcessInstanceCommentsWithHttpInfo
     *
     * Get Process Instance Comments
     *
     * @param  string $id The id of the process instance to retrieve the comments for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CommentDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessInstanceCommentsWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\CommentDto[]';
        $request = $this->getProcessInstanceCommentsRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CommentDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessInstanceCommentsAsync
     *
     * Get Process Instance Comments
     *
     * @param  string $id The id of the process instance to retrieve the comments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceCommentsAsync($id)
    {
        return $this->getProcessInstanceCommentsAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessInstanceCommentsAsyncWithHttpInfo
     *
     * Get Process Instance Comments
     *
     * @param  string $id The id of the process instance to retrieve the comments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceCommentsAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\CommentDto[]';
        $request = $this->getProcessInstanceCommentsRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessInstanceComments'
     *
     * @param  string $id The id of the process instance to retrieve the comments for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessInstanceCommentsRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessInstanceComments'
            );
        }

        $resourcePath = '/process-instance/{id}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessInstanceVariable
     *
     * Get Process Variable
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VariableValueDto
     */
    public function getProcessInstanceVariable($id, $var_name, $deserialize_value = 'true')
    {
        list($response) = $this->getProcessInstanceVariableWithHttpInfo($id, $var_name, $deserialize_value);
        return $response;
    }

    /**
     * Operation getProcessInstanceVariableWithHttpInfo
     *
     * Get Process Variable
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VariableValueDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessInstanceVariableWithHttpInfo($id, $var_name, $deserialize_value = 'true')
    {
        $returnType = '\Swagger\Client\Model\VariableValueDto';
        $request = $this->getProcessInstanceVariableRequest($id, $var_name, $deserialize_value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VariableValueDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessInstanceVariableAsync
     *
     * Get Process Variable
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceVariableAsync($id, $var_name, $deserialize_value = 'true')
    {
        return $this->getProcessInstanceVariableAsyncWithHttpInfo($id, $var_name, $deserialize_value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessInstanceVariableAsyncWithHttpInfo
     *
     * Get Process Variable
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceVariableAsyncWithHttpInfo($id, $var_name, $deserialize_value = 'true')
    {
        $returnType = '\Swagger\Client\Model\VariableValueDto';
        $request = $this->getProcessInstanceVariableRequest($id, $var_name, $deserialize_value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessInstanceVariable'
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  bool $deserialize_value Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessInstanceVariableRequest($id, $var_name, $deserialize_value = 'true')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessInstanceVariable'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling getProcessInstanceVariable'
            );
        }

        $resourcePath = '/process-instance/{id}/variables/{varName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deserialize_value !== null) {
            $queryParams['deserializeValue'] = ObjectSerializer::toQueryValue($deserialize_value, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessInstanceVariableBinary
     *
     * Get Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getProcessInstanceVariableBinary($id, $var_name)
    {
        list($response) = $this->getProcessInstanceVariableBinaryWithHttpInfo($id, $var_name);
        return $response;
    }

    /**
     * Operation getProcessInstanceVariableBinaryWithHttpInfo
     *
     * Get Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessInstanceVariableBinaryWithHttpInfo($id, $var_name)
    {
        $returnType = 'string';
        $request = $this->getProcessInstanceVariableBinaryRequest($id, $var_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessInstanceVariableBinaryAsync
     *
     * Get Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceVariableBinaryAsync($id, $var_name)
    {
        return $this->getProcessInstanceVariableBinaryAsyncWithHttpInfo($id, $var_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessInstanceVariableBinaryAsyncWithHttpInfo
     *
     * Get Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceVariableBinaryAsyncWithHttpInfo($id, $var_name)
    {
        $returnType = 'string';
        $request = $this->getProcessInstanceVariableBinaryRequest($id, $var_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessInstanceVariableBinary'
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessInstanceVariableBinaryRequest($id, $var_name)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessInstanceVariableBinary'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling getProcessInstanceVariableBinary'
            );
        }

        $resourcePath = '/process-instance/{id}/variables/{varName}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream', 'text/plain', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream', 'text/plain', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessInstanceVariables
     *
     * Get Process Variables
     *
     * @param  string $id The id of the process instance to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Swagger\Client\Model\VariableValueDto]
     */
    public function getProcessInstanceVariables($id, $deserialize_values = 'true')
    {
        list($response) = $this->getProcessInstanceVariablesWithHttpInfo($id, $deserialize_values);
        return $response;
    }

    /**
     * Operation getProcessInstanceVariablesWithHttpInfo
     *
     * Get Process Variables
     *
     * @param  string $id The id of the process instance to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Swagger\Client\Model\VariableValueDto], HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessInstanceVariablesWithHttpInfo($id, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->getProcessInstanceVariablesRequest($id, $deserialize_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Swagger\Client\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessInstanceVariablesAsync
     *
     * Get Process Variables
     *
     * @param  string $id The id of the process instance to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceVariablesAsync($id, $deserialize_values = 'true')
    {
        return $this->getProcessInstanceVariablesAsyncWithHttpInfo($id, $deserialize_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessInstanceVariablesAsyncWithHttpInfo
     *
     * Get Process Variables
     *
     * @param  string $id The id of the process instance to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstanceVariablesAsyncWithHttpInfo($id, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->getProcessInstanceVariablesRequest($id, $deserialize_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessInstanceVariables'
     *
     * @param  string $id The id of the process instance to retrieve the variables from. (required)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessInstanceVariablesRequest($id, $deserialize_values = 'true')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getProcessInstanceVariables'
            );
        }

        $resourcePath = '/process-instance/{id}/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($deserialize_values !== null) {
            $queryParams['deserializeValues'] = ObjectSerializer::toQueryValue($deserialize_values, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessInstances
     *
     * Get List
     *
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProcessInstanceDto[]
     */
    public function getProcessInstances($sort_by = null, $sort_order = null, $first_result = null, $max_results = null, $process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        list($response) = $this->getProcessInstancesWithHttpInfo($sort_by, $sort_order, $first_result, $max_results, $process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case);
        return $response;
    }

    /**
     * Operation getProcessInstancesWithHttpInfo
     *
     * Get List
     *
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProcessInstanceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessInstancesWithHttpInfo($sort_by = null, $sort_order = null, $first_result = null, $max_results = null, $process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        $returnType = '\Swagger\Client\Model\ProcessInstanceDto[]';
        $request = $this->getProcessInstancesRequest($sort_by, $sort_order, $first_result, $max_results, $process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProcessInstanceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessInstancesAsync
     *
     * Get List
     *
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstancesAsync($sort_by = null, $sort_order = null, $first_result = null, $max_results = null, $process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        return $this->getProcessInstancesAsyncWithHttpInfo($sort_by, $sort_order, $first_result, $max_results, $process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessInstancesAsyncWithHttpInfo
     *
     * Get List
     *
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstancesAsyncWithHttpInfo($sort_by = null, $sort_order = null, $first_result = null, $max_results = null, $process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        $returnType = '\Swagger\Client\Model\ProcessInstanceDto[]';
        $request = $this->getProcessInstancesRequest($sort_by, $sort_order, $first_result, $max_results, $process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessInstances'
     *
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessInstancesRequest($sort_by = null, $sort_order = null, $first_result = null, $max_results = null, $process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {

        $resourcePath = '/process-instance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order, null);
        }
        // query params
        if ($first_result !== null) {
            $queryParams['firstResult'] = ObjectSerializer::toQueryValue($first_result, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, null);
        }
        // query params
        if ($process_instance_ids !== null) {
            $queryParams['processInstanceIds'] = ObjectSerializer::toQueryValue($process_instance_ids, null);
        }
        // query params
        if ($business_key !== null) {
            $queryParams['businessKey'] = ObjectSerializer::toQueryValue($business_key, null);
        }
        // query params
        if ($business_key_like !== null) {
            $queryParams['businessKeyLike'] = ObjectSerializer::toQueryValue($business_key_like, null);
        }
        // query params
        if ($case_instance_id !== null) {
            $queryParams['caseInstanceId'] = ObjectSerializer::toQueryValue($case_instance_id, null);
        }
        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_key !== null) {
            $queryParams['processDefinitionKey'] = ObjectSerializer::toQueryValue($process_definition_key, null);
        }
        // query params
        if ($process_definition_key_in !== null) {
            $queryParams['processDefinitionKeyIn'] = ObjectSerializer::toQueryValue($process_definition_key_in, null);
        }
        // query params
        if ($process_definition_key_not_in !== null) {
            $queryParams['processDefinitionKeyNotIn'] = ObjectSerializer::toQueryValue($process_definition_key_not_in, null);
        }
        // query params
        if ($deployment_id !== null) {
            $queryParams['deploymentId'] = ObjectSerializer::toQueryValue($deployment_id, null);
        }
        // query params
        if ($super_process_instance !== null) {
            $queryParams['superProcessInstance'] = ObjectSerializer::toQueryValue($super_process_instance, null);
        }
        // query params
        if ($sub_process_instance !== null) {
            $queryParams['subProcessInstance'] = ObjectSerializer::toQueryValue($sub_process_instance, null);
        }
        // query params
        if ($super_case_instance !== null) {
            $queryParams['superCaseInstance'] = ObjectSerializer::toQueryValue($super_case_instance, null);
        }
        // query params
        if ($sub_case_instance !== null) {
            $queryParams['subCaseInstance'] = ObjectSerializer::toQueryValue($sub_case_instance, null);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active, null);
        }
        // query params
        if ($suspended !== null) {
            $queryParams['suspended'] = ObjectSerializer::toQueryValue($suspended, null);
        }
        // query params
        if ($with_incident !== null) {
            $queryParams['withIncident'] = ObjectSerializer::toQueryValue($with_incident, null);
        }
        // query params
        if ($incident_id !== null) {
            $queryParams['incidentId'] = ObjectSerializer::toQueryValue($incident_id, null);
        }
        // query params
        if ($incident_type !== null) {
            $queryParams['incidentType'] = ObjectSerializer::toQueryValue($incident_type, null);
        }
        // query params
        if ($incident_message !== null) {
            $queryParams['incidentMessage'] = ObjectSerializer::toQueryValue($incident_message, null);
        }
        // query params
        if ($incident_message_like !== null) {
            $queryParams['incidentMessageLike'] = ObjectSerializer::toQueryValue($incident_message_like, null);
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($process_definition_without_tenant_id !== null) {
            $queryParams['processDefinitionWithoutTenantId'] = ObjectSerializer::toQueryValue($process_definition_without_tenant_id, null);
        }
        // query params
        if ($activity_id_in !== null) {
            $queryParams['activityIdIn'] = ObjectSerializer::toQueryValue($activity_id_in, null);
        }
        // query params
        if ($root_process_instances !== null) {
            $queryParams['rootProcessInstances'] = ObjectSerializer::toQueryValue($root_process_instances, null);
        }
        // query params
        if ($leaf_process_instances !== null) {
            $queryParams['leafProcessInstances'] = ObjectSerializer::toQueryValue($leaf_process_instances, null);
        }
        // query params
        if ($variables !== null) {
            $queryParams['variables'] = ObjectSerializer::toQueryValue($variables, null);
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            $queryParams['variableNamesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_names_ignore_case, null);
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            $queryParams['variableValuesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_values_ignore_case, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProcessInstancesCount
     *
     * Get List Count
     *
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CountResultDto
     */
    public function getProcessInstancesCount($process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        list($response) = $this->getProcessInstancesCountWithHttpInfo($process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case);
        return $response;
    }

    /**
     * Operation getProcessInstancesCountWithHttpInfo
     *
     * Get List Count
     *
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CountResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProcessInstancesCountWithHttpInfo($process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->getProcessInstancesCountRequest($process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getProcessInstancesCountAsync
     *
     * Get List Count
     *
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstancesCountAsync($process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        return $this->getProcessInstancesCountAsyncWithHttpInfo($process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProcessInstancesCountAsyncWithHttpInfo
     *
     * Get List Count
     *
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProcessInstancesCountAsyncWithHttpInfo($process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->getProcessInstancesCountRequest($process_instance_ids, $business_key, $business_key_like, $case_instance_id, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_key_not_in, $deployment_id, $super_process_instance, $sub_process_instance, $super_case_instance, $sub_case_instance, $active, $suspended, $with_incident, $incident_id, $incident_type, $incident_message, $incident_message_like, $tenant_id_in, $without_tenant_id, $process_definition_without_tenant_id, $activity_id_in, $root_process_instances, $leaf_process_instances, $variables, $variable_names_ignore_case, $variable_values_ignore_case);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProcessInstancesCount'
     *
     * @param  string $process_instance_ids Filter by a comma-separated list of process instance ids. (optional)
     * @param  string $business_key Filter by process instance business key. (optional)
     * @param  string $business_key_like Filter by process instance business key that the parameter is a substring of. (optional)
     * @param  string $case_instance_id Filter by case instance id. (optional)
     * @param  string $process_definition_id Filter by the deployment the id belongs to. (optional)
     * @param  string $process_definition_key Filter by the key of the process definition the instances run on. (optional)
     * @param  string $process_definition_key_in Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys. (optional)
     * @param  string $process_definition_key_not_in Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys. (optional)
     * @param  string $deployment_id Filter by the deployment the id belongs to. (optional)
     * @param  string $super_process_instance Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id. (optional)
     * @param  string $sub_process_instance Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id. (optional)
     * @param  string $super_case_instance Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id. (optional)
     * @param  string $sub_case_instance Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id. (optional)
     * @param  bool $active Only include active process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended process instances. Value may only be true, as false is the default behavior. (optional, default to false)
     * @param  bool $with_incident Filter by presence of incidents. Selects only process instances that have an incident. (optional, default to false)
     * @param  string $incident_id Filter by the incident id. (optional)
     * @param  string $incident_type Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/incidents/#incident-types) for a list of incident types. (optional)
     * @param  string $incident_message Filter by the incident message. Exact match. (optional)
     * @param  string $incident_message_like Filter by the incident message that the parameter is a substring of. (optional)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include process instances which belong to no tenant. (optional, default to false)
     * @param  bool $process_definition_without_tenant_id Only include process instances which process definition has no tenant id. (optional, default to false)
     * @param  string $activity_id_in Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids. (optional)
     * @param  bool $root_process_instances Restrict the query to all process instances that are top level process instances. (optional, default to false)
     * @param  bool $leaf_process_instances Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances). (optional, default to false)
     * @param  string $variables Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getProcessInstancesCountRequest($process_instance_ids = null, $business_key = null, $business_key_like = null, $case_instance_id = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_key_not_in = null, $deployment_id = null, $super_process_instance = null, $sub_process_instance = null, $super_case_instance = null, $sub_case_instance = null, $active = 'false', $suspended = 'false', $with_incident = 'false', $incident_id = null, $incident_type = null, $incident_message = null, $incident_message_like = null, $tenant_id_in = null, $without_tenant_id = 'false', $process_definition_without_tenant_id = 'false', $activity_id_in = null, $root_process_instances = 'false', $leaf_process_instances = 'false', $variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false')
    {

        $resourcePath = '/process-instance/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($process_instance_ids !== null) {
            $queryParams['processInstanceIds'] = ObjectSerializer::toQueryValue($process_instance_ids, null);
        }
        // query params
        if ($business_key !== null) {
            $queryParams['businessKey'] = ObjectSerializer::toQueryValue($business_key, null);
        }
        // query params
        if ($business_key_like !== null) {
            $queryParams['businessKeyLike'] = ObjectSerializer::toQueryValue($business_key_like, null);
        }
        // query params
        if ($case_instance_id !== null) {
            $queryParams['caseInstanceId'] = ObjectSerializer::toQueryValue($case_instance_id, null);
        }
        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_key !== null) {
            $queryParams['processDefinitionKey'] = ObjectSerializer::toQueryValue($process_definition_key, null);
        }
        // query params
        if ($process_definition_key_in !== null) {
            $queryParams['processDefinitionKeyIn'] = ObjectSerializer::toQueryValue($process_definition_key_in, null);
        }
        // query params
        if ($process_definition_key_not_in !== null) {
            $queryParams['processDefinitionKeyNotIn'] = ObjectSerializer::toQueryValue($process_definition_key_not_in, null);
        }
        // query params
        if ($deployment_id !== null) {
            $queryParams['deploymentId'] = ObjectSerializer::toQueryValue($deployment_id, null);
        }
        // query params
        if ($super_process_instance !== null) {
            $queryParams['superProcessInstance'] = ObjectSerializer::toQueryValue($super_process_instance, null);
        }
        // query params
        if ($sub_process_instance !== null) {
            $queryParams['subProcessInstance'] = ObjectSerializer::toQueryValue($sub_process_instance, null);
        }
        // query params
        if ($super_case_instance !== null) {
            $queryParams['superCaseInstance'] = ObjectSerializer::toQueryValue($super_case_instance, null);
        }
        // query params
        if ($sub_case_instance !== null) {
            $queryParams['subCaseInstance'] = ObjectSerializer::toQueryValue($sub_case_instance, null);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active, null);
        }
        // query params
        if ($suspended !== null) {
            $queryParams['suspended'] = ObjectSerializer::toQueryValue($suspended, null);
        }
        // query params
        if ($with_incident !== null) {
            $queryParams['withIncident'] = ObjectSerializer::toQueryValue($with_incident, null);
        }
        // query params
        if ($incident_id !== null) {
            $queryParams['incidentId'] = ObjectSerializer::toQueryValue($incident_id, null);
        }
        // query params
        if ($incident_type !== null) {
            $queryParams['incidentType'] = ObjectSerializer::toQueryValue($incident_type, null);
        }
        // query params
        if ($incident_message !== null) {
            $queryParams['incidentMessage'] = ObjectSerializer::toQueryValue($incident_message, null);
        }
        // query params
        if ($incident_message_like !== null) {
            $queryParams['incidentMessageLike'] = ObjectSerializer::toQueryValue($incident_message_like, null);
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($process_definition_without_tenant_id !== null) {
            $queryParams['processDefinitionWithoutTenantId'] = ObjectSerializer::toQueryValue($process_definition_without_tenant_id, null);
        }
        // query params
        if ($activity_id_in !== null) {
            $queryParams['activityIdIn'] = ObjectSerializer::toQueryValue($activity_id_in, null);
        }
        // query params
        if ($root_process_instances !== null) {
            $queryParams['rootProcessInstances'] = ObjectSerializer::toQueryValue($root_process_instances, null);
        }
        // query params
        if ($leaf_process_instances !== null) {
            $queryParams['leafProcessInstances'] = ObjectSerializer::toQueryValue($leaf_process_instances, null);
        }
        // query params
        if ($variables !== null) {
            $queryParams['variables'] = ObjectSerializer::toQueryValue($variables, null);
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            $queryParams['variableNamesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_names_ignore_case, null);
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            $queryParams['variableValuesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_values_ignore_case, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyProcessInstance
     *
     * Modify Process Instance Execution State
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modifyProcessInstance($id, $body = null)
    {
        $this->modifyProcessInstanceWithHttpInfo($id, $body);
    }

    /**
     * Operation modifyProcessInstanceWithHttpInfo
     *
     * Modify Process Instance Execution State
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyProcessInstanceWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->modifyProcessInstanceRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modifyProcessInstanceAsync
     *
     * Modify Process Instance Execution State
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyProcessInstanceAsync($id, $body = null)
    {
        return $this->modifyProcessInstanceAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyProcessInstanceAsyncWithHttpInfo
     *
     * Modify Process Instance Execution State
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyProcessInstanceAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->modifyProcessInstanceRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyProcessInstance'
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function modifyProcessInstanceRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modifyProcessInstance'
            );
        }

        $resourcePath = '/process-instance/{id}/modification';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyProcessInstanceAsyncOperation
     *
     * Modify Process Instance Execution State Async
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function modifyProcessInstanceAsyncOperation($id, $body = null)
    {
        list($response) = $this->modifyProcessInstanceAsyncOperationWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation modifyProcessInstanceAsyncOperationWithHttpInfo
     *
     * Modify Process Instance Execution State Async
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyProcessInstanceAsyncOperationWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->modifyProcessInstanceAsyncOperationRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modifyProcessInstanceAsyncOperationAsync
     *
     * Modify Process Instance Execution State Async
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyProcessInstanceAsyncOperationAsync($id, $body = null)
    {
        return $this->modifyProcessInstanceAsyncOperationAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyProcessInstanceAsyncOperationAsyncWithHttpInfo
     *
     * Modify Process Instance Execution State Async
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyProcessInstanceAsyncOperationAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->modifyProcessInstanceAsyncOperationRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyProcessInstanceAsyncOperation'
     *
     * @param  string $id The id of the process instance to modify. (required)
     * @param  \Swagger\Client\Model\ProcessInstanceModificationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function modifyProcessInstanceAsyncOperationRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modifyProcessInstanceAsyncOperation'
            );
        }

        $resourcePath = '/process-instance/{id}/modification-async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation modifyProcessInstanceVariables
     *
     * Update/Delete Process Variables
     *
     * @param  string $id The id of the process instance to set variables for. (required)
     * @param  \Swagger\Client\Model\PatchVariablesDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function modifyProcessInstanceVariables($id, $body = null)
    {
        $this->modifyProcessInstanceVariablesWithHttpInfo($id, $body);
    }

    /**
     * Operation modifyProcessInstanceVariablesWithHttpInfo
     *
     * Update/Delete Process Variables
     *
     * @param  string $id The id of the process instance to set variables for. (required)
     * @param  \Swagger\Client\Model\PatchVariablesDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function modifyProcessInstanceVariablesWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->modifyProcessInstanceVariablesRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation modifyProcessInstanceVariablesAsync
     *
     * Update/Delete Process Variables
     *
     * @param  string $id The id of the process instance to set variables for. (required)
     * @param  \Swagger\Client\Model\PatchVariablesDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyProcessInstanceVariablesAsync($id, $body = null)
    {
        return $this->modifyProcessInstanceVariablesAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation modifyProcessInstanceVariablesAsyncWithHttpInfo
     *
     * Update/Delete Process Variables
     *
     * @param  string $id The id of the process instance to set variables for. (required)
     * @param  \Swagger\Client\Model\PatchVariablesDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function modifyProcessInstanceVariablesAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->modifyProcessInstanceVariablesRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'modifyProcessInstanceVariables'
     *
     * @param  string $id The id of the process instance to set variables for. (required)
     * @param  \Swagger\Client\Model\PatchVariablesDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function modifyProcessInstanceVariablesRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling modifyProcessInstanceVariables'
            );
        }

        $resourcePath = '/process-instance/{id}/variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryProcessInstances
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ProcessInstanceDto[]
     */
    public function queryProcessInstances($body = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->queryProcessInstancesWithHttpInfo($body, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation queryProcessInstancesWithHttpInfo
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ProcessInstanceDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function queryProcessInstancesWithHttpInfo($body = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Swagger\Client\Model\ProcessInstanceDto[]';
        $request = $this->queryProcessInstancesRequest($body, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ProcessInstanceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryProcessInstancesAsync
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryProcessInstancesAsync($body = null, $first_result = null, $max_results = null)
    {
        return $this->queryProcessInstancesAsyncWithHttpInfo($body, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryProcessInstancesAsyncWithHttpInfo
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryProcessInstancesAsyncWithHttpInfo($body = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Swagger\Client\Model\ProcessInstanceDto[]';
        $request = $this->queryProcessInstancesRequest($body, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryProcessInstances'
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryProcessInstancesRequest($body = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/process-instance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($first_result !== null) {
            $queryParams['firstResult'] = ObjectSerializer::toQueryValue($first_result, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryProcessInstancesCount
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CountResultDto
     */
    public function queryProcessInstancesCount($body = null)
    {
        list($response) = $this->queryProcessInstancesCountWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation queryProcessInstancesCountWithHttpInfo
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CountResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryProcessInstancesCountWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->queryProcessInstancesCountRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryProcessInstancesCountAsync
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryProcessInstancesCountAsync($body = null)
    {
        return $this->queryProcessInstancesCountAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryProcessInstancesCountAsyncWithHttpInfo
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryProcessInstancesCountAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->queryProcessInstancesCountRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryProcessInstancesCount'
     *
     * @param  \Swagger\Client\Model\ProcessInstanceQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryProcessInstancesCountRequest($body = null)
    {

        $resourcePath = '/process-instance/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setProcessInstanceVariable
     *
     * Update Process Variable
     *
     * @param  string $id The id of the process instance to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \Swagger\Client\Model\VariableValueDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setProcessInstanceVariable($id, $var_name, $body = null)
    {
        $this->setProcessInstanceVariableWithHttpInfo($id, $var_name, $body);
    }

    /**
     * Operation setProcessInstanceVariableWithHttpInfo
     *
     * Update Process Variable
     *
     * @param  string $id The id of the process instance to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \Swagger\Client\Model\VariableValueDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setProcessInstanceVariableWithHttpInfo($id, $var_name, $body = null)
    {
        $returnType = '';
        $request = $this->setProcessInstanceVariableRequest($id, $var_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setProcessInstanceVariableAsync
     *
     * Update Process Variable
     *
     * @param  string $id The id of the process instance to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \Swagger\Client\Model\VariableValueDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setProcessInstanceVariableAsync($id, $var_name, $body = null)
    {
        return $this->setProcessInstanceVariableAsyncWithHttpInfo($id, $var_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setProcessInstanceVariableAsyncWithHttpInfo
     *
     * Update Process Variable
     *
     * @param  string $id The id of the process instance to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \Swagger\Client\Model\VariableValueDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setProcessInstanceVariableAsyncWithHttpInfo($id, $var_name, $body = null)
    {
        $returnType = '';
        $request = $this->setProcessInstanceVariableRequest($id, $var_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setProcessInstanceVariable'
     *
     * @param  string $id The id of the process instance to set the variable for. (required)
     * @param  string $var_name The name of the variable to set. (required)
     * @param  \Swagger\Client\Model\VariableValueDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setProcessInstanceVariableRequest($id, $var_name, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setProcessInstanceVariable'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling setProcessInstanceVariable'
            );
        }

        $resourcePath = '/process-instance/{id}/variables/{varName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setProcessInstanceVariableBinary
     *
     * Update Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  string $data data (optional)
     * @param  string $value_type value_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setProcessInstanceVariableBinary($id, $var_name, $data = null, $value_type = null)
    {
        $this->setProcessInstanceVariableBinaryWithHttpInfo($id, $var_name, $data, $value_type);
    }

    /**
     * Operation setProcessInstanceVariableBinaryWithHttpInfo
     *
     * Update Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  string $data (optional)
     * @param  string $value_type (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setProcessInstanceVariableBinaryWithHttpInfo($id, $var_name, $data = null, $value_type = null)
    {
        $returnType = '';
        $request = $this->setProcessInstanceVariableBinaryRequest($id, $var_name, $data, $value_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setProcessInstanceVariableBinaryAsync
     *
     * Update Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  string $data (optional)
     * @param  string $value_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setProcessInstanceVariableBinaryAsync($id, $var_name, $data = null, $value_type = null)
    {
        return $this->setProcessInstanceVariableBinaryAsyncWithHttpInfo($id, $var_name, $data, $value_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setProcessInstanceVariableBinaryAsyncWithHttpInfo
     *
     * Update Process Variable (Binary)
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  string $data (optional)
     * @param  string $value_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setProcessInstanceVariableBinaryAsyncWithHttpInfo($id, $var_name, $data = null, $value_type = null)
    {
        $returnType = '';
        $request = $this->setProcessInstanceVariableBinaryRequest($id, $var_name, $data, $value_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setProcessInstanceVariableBinary'
     *
     * @param  string $id The id of the process instance to retrieve the variable for. (required)
     * @param  string $var_name The name of the variable to retrieve. (required)
     * @param  string $data (optional)
     * @param  string $value_type (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setProcessInstanceVariableBinaryRequest($id, $var_name, $data = null, $value_type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setProcessInstanceVariableBinary'
            );
        }
        // verify the required parameter 'var_name' is set
        if ($var_name === null || (is_array($var_name) && count($var_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $var_name when calling setProcessInstanceVariableBinary'
            );
        }

        $resourcePath = '/process-instance/{id}/variables/{varName}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($var_name !== null) {
            $resourcePath = str_replace(
                '{' . 'varName' . '}',
                ObjectSerializer::toPathValue($var_name),
                $resourcePath
            );
        }

        // form params
        if ($data !== null) {
            $multipart = true;
            $formParams['data'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($data), 'rb');
        }
        // form params
        if ($value_type !== null) {
            $formParams['valueType'] = ObjectSerializer::toFormValue($value_type);
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setRetriesByProcess
     *
     * Set Job Retries Async (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function setRetriesByProcess($body = null)
    {
        list($response) = $this->setRetriesByProcessWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation setRetriesByProcessWithHttpInfo
     *
     * Set Job Retries Async (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRetriesByProcessWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->setRetriesByProcessRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setRetriesByProcessAsync
     *
     * Set Job Retries Async (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRetriesByProcessAsync($body = null)
    {
        return $this->setRetriesByProcessAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setRetriesByProcessAsyncWithHttpInfo
     *
     * Set Job Retries Async (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRetriesByProcessAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->setRetriesByProcessRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setRetriesByProcess'
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setRetriesByProcessRequest($body = null)
    {

        $resourcePath = '/process-instance/job-retries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setRetriesByProcessHistoricQueryBased
     *
     * Set Job Retries Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function setRetriesByProcessHistoricQueryBased($body = null)
    {
        list($response) = $this->setRetriesByProcessHistoricQueryBasedWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation setRetriesByProcessHistoricQueryBasedWithHttpInfo
     *
     * Set Job Retries Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRetriesByProcessHistoricQueryBasedWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->setRetriesByProcessHistoricQueryBasedRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setRetriesByProcessHistoricQueryBasedAsync
     *
     * Set Job Retries Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRetriesByProcessHistoricQueryBasedAsync($body = null)
    {
        return $this->setRetriesByProcessHistoricQueryBasedAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setRetriesByProcessHistoricQueryBasedAsyncWithHttpInfo
     *
     * Set Job Retries Async Historic Query Based (POST)
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRetriesByProcessHistoricQueryBasedAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->setRetriesByProcessHistoricQueryBasedRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setRetriesByProcessHistoricQueryBased'
     *
     * @param  \Swagger\Client\Model\SetJobRetriesByProcessDto $body Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setRetriesByProcessHistoricQueryBasedRequest($body = null)
    {

        $resourcePath = '/process-instance/job-retries-historic-query-based';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setVariablesAsyncOperation
     *
     * Set Variables Async (POST)
     *
     * @param  \Swagger\Client\Model\SetVariablesAsyncDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function setVariablesAsyncOperation($body = null)
    {
        list($response) = $this->setVariablesAsyncOperationWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation setVariablesAsyncOperationWithHttpInfo
     *
     * Set Variables Async (POST)
     *
     * @param  \Swagger\Client\Model\SetVariablesAsyncDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function setVariablesAsyncOperationWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->setVariablesAsyncOperationRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setVariablesAsyncOperationAsync
     *
     * Set Variables Async (POST)
     *
     * @param  \Swagger\Client\Model\SetVariablesAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setVariablesAsyncOperationAsync($body = null)
    {
        return $this->setVariablesAsyncOperationAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setVariablesAsyncOperationAsyncWithHttpInfo
     *
     * Set Variables Async (POST)
     *
     * @param  \Swagger\Client\Model\SetVariablesAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setVariablesAsyncOperationAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->setVariablesAsyncOperationRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setVariablesAsyncOperation'
     *
     * @param  \Swagger\Client\Model\SetVariablesAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setVariablesAsyncOperationRequest($body = null)
    {

        $resourcePath = '/process-instance/variables-async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSuspensionState
     *
     * Activate/Suspend In Group
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateSuspensionState($body = null)
    {
        $this->updateSuspensionStateWithHttpInfo($body);
    }

    /**
     * Operation updateSuspensionStateWithHttpInfo
     *
     * Activate/Suspend In Group
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSuspensionStateWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->updateSuspensionStateRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateSuspensionStateAsync
     *
     * Activate/Suspend In Group
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSuspensionStateAsync($body = null)
    {
        return $this->updateSuspensionStateAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSuspensionStateAsyncWithHttpInfo
     *
     * Activate/Suspend In Group
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSuspensionStateAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->updateSuspensionStateRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSuspensionState'
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateSuspensionStateRequest($body = null)
    {

        $resourcePath = '/process-instance/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSuspensionStateAsyncOperation
     *
     * Activate/Suspend In Batch
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateAsyncDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BatchDto
     */
    public function updateSuspensionStateAsyncOperation($body = null)
    {
        list($response) = $this->updateSuspensionStateAsyncOperationWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation updateSuspensionStateAsyncOperationWithHttpInfo
     *
     * Activate/Suspend In Batch
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateAsyncDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BatchDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSuspensionStateAsyncOperationWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->updateSuspensionStateAsyncOperationRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BatchDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateSuspensionStateAsyncOperationAsync
     *
     * Activate/Suspend In Batch
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSuspensionStateAsyncOperationAsync($body = null)
    {
        return $this->updateSuspensionStateAsyncOperationAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSuspensionStateAsyncOperationAsyncWithHttpInfo
     *
     * Activate/Suspend In Batch
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSuspensionStateAsyncOperationAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\BatchDto';
        $request = $this->updateSuspensionStateAsyncOperationRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSuspensionStateAsyncOperation'
     *
     * @param  \Swagger\Client\Model\ProcessInstanceSuspensionStateAsyncDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateSuspensionStateAsyncOperationRequest($body = null)
    {

        $resourcePath = '/process-instance/suspended-async';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSuspensionStateById
     *
     * Activate/Suspend Process Instance By Id
     *
     * @param  string $id The id of the process instance to activate or suspend. (required)
     * @param  \Swagger\Client\Model\SuspensionStateDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateSuspensionStateById($id, $body = null)
    {
        $this->updateSuspensionStateByIdWithHttpInfo($id, $body);
    }

    /**
     * Operation updateSuspensionStateByIdWithHttpInfo
     *
     * Activate/Suspend Process Instance By Id
     *
     * @param  string $id The id of the process instance to activate or suspend. (required)
     * @param  \Swagger\Client\Model\SuspensionStateDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSuspensionStateByIdWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateSuspensionStateByIdRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateSuspensionStateByIdAsync
     *
     * Activate/Suspend Process Instance By Id
     *
     * @param  string $id The id of the process instance to activate or suspend. (required)
     * @param  \Swagger\Client\Model\SuspensionStateDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSuspensionStateByIdAsync($id, $body = null)
    {
        return $this->updateSuspensionStateByIdAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSuspensionStateByIdAsyncWithHttpInfo
     *
     * Activate/Suspend Process Instance By Id
     *
     * @param  string $id The id of the process instance to activate or suspend. (required)
     * @param  \Swagger\Client\Model\SuspensionStateDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSuspensionStateByIdAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateSuspensionStateByIdRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSuspensionStateById'
     *
     * @param  string $id The id of the process instance to activate or suspend. (required)
     * @param  \Swagger\Client\Model\SuspensionStateDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateSuspensionStateByIdRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateSuspensionStateById'
            );
        }

        $resourcePath = '/process-instance/{id}/suspended';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
