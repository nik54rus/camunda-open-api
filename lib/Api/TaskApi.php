<?php
/**
 * TaskApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Camunda Platform REST API
 *
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.21.1-ee
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.56
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * TaskApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TaskApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation claim
     *
     * Claim
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that claims the task. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function claim($id, $body = null)
    {
        $this->claimWithHttpInfo($id, $body);
    }

    /**
     * Operation claimWithHttpInfo
     *
     * Claim
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that claims the task. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function claimWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->claimRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation claimAsync
     *
     * Claim
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that claims the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimAsync($id, $body = null)
    {
        return $this->claimAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation claimAsyncWithHttpInfo
     *
     * Claim
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that claims the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->claimRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'claim'
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that claims the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function claimRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling claim'
            );
        }

        $resourcePath = '/task/{id}/claim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation complete
     *
     * Complete
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Swagger\Client\Model\VariableValueDto]
     */
    public function complete($id, $body = null)
    {
        list($response) = $this->completeWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation completeWithHttpInfo
     *
     * Complete
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Swagger\Client\Model\VariableValueDto], HTTP status code, HTTP response headers (array of strings)
     */
    public function completeWithHttpInfo($id, $body = null)
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->completeRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Swagger\Client\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation completeAsync
     *
     * Complete
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeAsync($id, $body = null)
    {
        return $this->completeAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeAsyncWithHttpInfo
     *
     * Complete
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->completeRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'complete'
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function completeRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling complete'
            );
        }

        $resourcePath = '/task/{id}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTask
     *
     * Create
     *
     * @param  \Swagger\Client\Model\TaskDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createTask($body = null)
    {
        $this->createTaskWithHttpInfo($body);
    }

    /**
     * Operation createTaskWithHttpInfo
     *
     * Create
     *
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->createTaskRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaskAsync
     *
     * Create
     *
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsync($body = null)
    {
        return $this->createTaskAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskAsyncWithHttpInfo
     *
     * Create
     *
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsyncWithHttpInfo($body = null)
    {
        $returnType = '';
        $request = $this->createTaskRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTask'
     *
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTaskRequest($body = null)
    {

        $resourcePath = '/task/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation delegateTask
     *
     * Delegate
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function delegateTask($id, $body = null)
    {
        $this->delegateTaskWithHttpInfo($id, $body);
    }

    /**
     * Operation delegateTaskWithHttpInfo
     *
     * Delegate
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function delegateTaskWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->delegateTaskRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation delegateTaskAsync
     *
     * Delegate
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function delegateTaskAsync($id, $body = null)
    {
        return $this->delegateTaskAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation delegateTaskAsyncWithHttpInfo
     *
     * Delegate
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function delegateTaskAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->delegateTaskRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'delegateTask'
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function delegateTaskRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling delegateTask'
            );
        }

        $resourcePath = '/task/{id}/delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTask
     *
     * Delete
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTask($id)
    {
        $this->deleteTaskWithHttpInfo($id);
    }

    /**
     * Operation deleteTaskWithHttpInfo
     *
     * Delete
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTaskAsync
     *
     * Delete
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsync($id)
    {
        return $this->deleteTaskAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskAsyncWithHttpInfo
     *
     * Delete
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTask'
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTaskRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteTask'
            );
        }

        $resourcePath = '/task/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeployedForm
     *
     * Get Deployed Form
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getDeployedForm($id)
    {
        list($response) = $this->getDeployedFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDeployedFormWithHttpInfo
     *
     * Get Deployed Form
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeployedFormWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getDeployedFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeployedFormAsync
     *
     * Get Deployed Form
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedFormAsync($id)
    {
        return $this->getDeployedFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeployedFormAsyncWithHttpInfo
     *
     * Get Deployed Form
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedFormAsyncWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getDeployedFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeployedForm'
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeployedFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeployedForm'
            );
        }

        $resourcePath = '/task/{id}/deployed-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getForm
     *
     * Get Form Key
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FormDto
     */
    public function getForm($id)
    {
        list($response) = $this->getFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFormWithHttpInfo
     *
     * Get Form Key
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FormDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFormWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FormDto';
        $request = $this->getFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FormDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFormAsync
     *
     * Get Form Key
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormAsync($id)
    {
        return $this->getFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFormAsyncWithHttpInfo
     *
     * Get Form Key
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\FormDto';
        $request = $this->getFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getForm'
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getForm'
            );
        }

        $resourcePath = '/task/{id}/form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFormVariables
     *
     * Get Task Form Variables
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Swagger\Client\Model\VariableValueDto]
     */
    public function getFormVariables($id, $variable_names = null, $deserialize_values = 'true')
    {
        list($response) = $this->getFormVariablesWithHttpInfo($id, $variable_names, $deserialize_values);
        return $response;
    }

    /**
     * Operation getFormVariablesWithHttpInfo
     *
     * Get Task Form Variables
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Swagger\Client\Model\VariableValueDto], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFormVariablesWithHttpInfo($id, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->getFormVariablesRequest($id, $variable_names, $deserialize_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Swagger\Client\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFormVariablesAsync
     *
     * Get Task Form Variables
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormVariablesAsync($id, $variable_names = null, $deserialize_values = 'true')
    {
        return $this->getFormVariablesAsyncWithHttpInfo($id, $variable_names, $deserialize_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFormVariablesAsyncWithHttpInfo
     *
     * Get Task Form Variables
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormVariablesAsyncWithHttpInfo($id, $variable_names = null, $deserialize_values = 'true')
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->getFormVariablesRequest($id, $variable_names, $deserialize_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFormVariables'
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFormVariablesRequest($id, $variable_names = null, $deserialize_values = 'true')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFormVariables'
            );
        }

        $resourcePath = '/task/{id}/form-variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variable_names !== null) {
            $queryParams['variableNames'] = ObjectSerializer::toQueryValue($variable_names, null);
        }
        // query params
        if ($deserialize_values !== null) {
            $queryParams['deserializeValues'] = ObjectSerializer::toQueryValue($deserialize_values, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRenderedForm
     *
     * Get Rendered Form
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getRenderedForm($id)
    {
        list($response) = $this->getRenderedFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRenderedFormWithHttpInfo
     *
     * Get Rendered Form
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRenderedFormWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getRenderedFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRenderedFormAsync
     *
     * Get Rendered Form
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedFormAsync($id)
    {
        return $this->getRenderedFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRenderedFormAsyncWithHttpInfo
     *
     * Get Rendered Form
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedFormAsyncWithHttpInfo($id)
    {
        $returnType = 'string';
        $request = $this->getRenderedFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRenderedForm'
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRenderedFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRenderedForm'
            );
        }

        $resourcePath = '/task/{id}/rendered-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTask
     *
     * Get
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskDto
     */
    public function getTask($id)
    {
        list($response) = $this->getTaskWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTaskWithHttpInfo
     *
     * Get
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TaskDto';
        $request = $this->getTaskRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaskAsync
     *
     * Get
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsync($id)
    {
        return $this->getTaskAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskAsyncWithHttpInfo
     *
     * Get
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\TaskDto';
        $request = $this->getTaskRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTask'
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTaskRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTask'
            );
        }

        $resourcePath = '/task/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTaskCountByCandidateGroup
     *
     * Get Task Count By Candidate Group
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskCountByCandidateGroupResultDto[]
     */
    public function getTaskCountByCandidateGroup()
    {
        list($response) = $this->getTaskCountByCandidateGroupWithHttpInfo();
        return $response;
    }

    /**
     * Operation getTaskCountByCandidateGroupWithHttpInfo
     *
     * Get Task Count By Candidate Group
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskCountByCandidateGroupResultDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskCountByCandidateGroupWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\TaskCountByCandidateGroupResultDto[]';
        $request = $this->getTaskCountByCandidateGroupRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskCountByCandidateGroupResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaskCountByCandidateGroupAsync
     *
     * Get Task Count By Candidate Group
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskCountByCandidateGroupAsync()
    {
        return $this->getTaskCountByCandidateGroupAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskCountByCandidateGroupAsyncWithHttpInfo
     *
     * Get Task Count By Candidate Group
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskCountByCandidateGroupAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\TaskCountByCandidateGroupResultDto[]';
        $request = $this->getTaskCountByCandidateGroupRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTaskCountByCandidateGroup'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTaskCountByCandidateGroupRequest()
    {

        $resourcePath = '/task/report/candidate-group-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/csv', 'text/csv']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/csv', 'text/csv'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTasks
     *
     * Get List
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskDto[]
     */
    public function getTasks($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->getTasksWithHttpInfo($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation getTasksWithHttpInfo
     *
     * Get List
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTasksWithHttpInfo($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Swagger\Client\Model\TaskDto[]';
        $request = $this->getTasksRequest($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTasksAsync
     *
     * Get List
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksAsync($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        return $this->getTasksAsyncWithHttpInfo($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTasksAsyncWithHttpInfo
     *
     * Get List
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksAsyncWithHttpInfo($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Swagger\Client\Model\TaskDto[]';
        $request = $this->getTasksRequest($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTasks'
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTasksRequest($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_id !== null) {
            $queryParams['taskId'] = ObjectSerializer::toQueryValue($task_id, null);
        }
        // query params
        if ($task_id_in !== null) {
            $queryParams['taskIdIn'] = ObjectSerializer::toQueryValue($task_id_in, null);
        }
        // query params
        if ($process_instance_id !== null) {
            $queryParams['processInstanceId'] = ObjectSerializer::toQueryValue($process_instance_id, null);
        }
        // query params
        if ($process_instance_id_in !== null) {
            $queryParams['processInstanceIdIn'] = ObjectSerializer::toQueryValue($process_instance_id_in, null);
        }
        // query params
        if ($process_instance_business_key !== null) {
            $queryParams['processInstanceBusinessKey'] = ObjectSerializer::toQueryValue($process_instance_business_key, null);
        }
        // query params
        if ($process_instance_business_key_expression !== null) {
            $queryParams['processInstanceBusinessKeyExpression'] = ObjectSerializer::toQueryValue($process_instance_business_key_expression, null);
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            $queryParams['processInstanceBusinessKeyIn'] = ObjectSerializer::toQueryValue($process_instance_business_key_in, null);
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            $queryParams['processInstanceBusinessKeyLike'] = ObjectSerializer::toQueryValue($process_instance_business_key_like, null);
        }
        // query params
        if ($process_instance_business_key_like_expression !== null) {
            $queryParams['processInstanceBusinessKeyLikeExpression'] = ObjectSerializer::toQueryValue($process_instance_business_key_like_expression, null);
        }
        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_key !== null) {
            $queryParams['processDefinitionKey'] = ObjectSerializer::toQueryValue($process_definition_key, null);
        }
        // query params
        if ($process_definition_key_in !== null) {
            $queryParams['processDefinitionKeyIn'] = ObjectSerializer::toQueryValue($process_definition_key_in, null);
        }
        // query params
        if ($process_definition_name !== null) {
            $queryParams['processDefinitionName'] = ObjectSerializer::toQueryValue($process_definition_name, null);
        }
        // query params
        if ($process_definition_name_like !== null) {
            $queryParams['processDefinitionNameLike'] = ObjectSerializer::toQueryValue($process_definition_name_like, null);
        }
        // query params
        if ($execution_id !== null) {
            $queryParams['executionId'] = ObjectSerializer::toQueryValue($execution_id, null);
        }
        // query params
        if ($case_instance_id !== null) {
            $queryParams['caseInstanceId'] = ObjectSerializer::toQueryValue($case_instance_id, null);
        }
        // query params
        if ($case_instance_business_key !== null) {
            $queryParams['caseInstanceBusinessKey'] = ObjectSerializer::toQueryValue($case_instance_business_key, null);
        }
        // query params
        if ($case_instance_business_key_like !== null) {
            $queryParams['caseInstanceBusinessKeyLike'] = ObjectSerializer::toQueryValue($case_instance_business_key_like, null);
        }
        // query params
        if ($case_definition_id !== null) {
            $queryParams['caseDefinitionId'] = ObjectSerializer::toQueryValue($case_definition_id, null);
        }
        // query params
        if ($case_definition_key !== null) {
            $queryParams['caseDefinitionKey'] = ObjectSerializer::toQueryValue($case_definition_key, null);
        }
        // query params
        if ($case_definition_name !== null) {
            $queryParams['caseDefinitionName'] = ObjectSerializer::toQueryValue($case_definition_name, null);
        }
        // query params
        if ($case_definition_name_like !== null) {
            $queryParams['caseDefinitionNameLike'] = ObjectSerializer::toQueryValue($case_definition_name_like, null);
        }
        // query params
        if ($case_execution_id !== null) {
            $queryParams['caseExecutionId'] = ObjectSerializer::toQueryValue($case_execution_id, null);
        }
        // query params
        if ($activity_instance_id_in !== null) {
            $queryParams['activityInstanceIdIn'] = ObjectSerializer::toQueryValue($activity_instance_id_in, null);
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($assignee !== null) {
            $queryParams['assignee'] = ObjectSerializer::toQueryValue($assignee, null);
        }
        // query params
        if ($assignee_expression !== null) {
            $queryParams['assigneeExpression'] = ObjectSerializer::toQueryValue($assignee_expression, null);
        }
        // query params
        if ($assignee_like !== null) {
            $queryParams['assigneeLike'] = ObjectSerializer::toQueryValue($assignee_like, null);
        }
        // query params
        if ($assignee_like_expression !== null) {
            $queryParams['assigneeLikeExpression'] = ObjectSerializer::toQueryValue($assignee_like_expression, null);
        }
        // query params
        if ($assignee_in !== null) {
            $queryParams['assigneeIn'] = ObjectSerializer::toQueryValue($assignee_in, null);
        }
        // query params
        if ($assignee_not_in !== null) {
            $queryParams['assigneeNotIn'] = ObjectSerializer::toQueryValue($assignee_not_in, null);
        }
        // query params
        if ($owner !== null) {
            $queryParams['owner'] = ObjectSerializer::toQueryValue($owner, null);
        }
        // query params
        if ($owner_expression !== null) {
            $queryParams['ownerExpression'] = ObjectSerializer::toQueryValue($owner_expression, null);
        }
        // query params
        if ($candidate_group !== null) {
            $queryParams['candidateGroup'] = ObjectSerializer::toQueryValue($candidate_group, null);
        }
        // query params
        if ($candidate_group_expression !== null) {
            $queryParams['candidateGroupExpression'] = ObjectSerializer::toQueryValue($candidate_group_expression, null);
        }
        // query params
        if ($candidate_user !== null) {
            $queryParams['candidateUser'] = ObjectSerializer::toQueryValue($candidate_user, null);
        }
        // query params
        if ($candidate_user_expression !== null) {
            $queryParams['candidateUserExpression'] = ObjectSerializer::toQueryValue($candidate_user_expression, null);
        }
        // query params
        if ($include_assigned_tasks !== null) {
            $queryParams['includeAssignedTasks'] = ObjectSerializer::toQueryValue($include_assigned_tasks, null);
        }
        // query params
        if ($involved_user !== null) {
            $queryParams['involvedUser'] = ObjectSerializer::toQueryValue($involved_user, null);
        }
        // query params
        if ($involved_user_expression !== null) {
            $queryParams['involvedUserExpression'] = ObjectSerializer::toQueryValue($involved_user_expression, null);
        }
        // query params
        if ($assigned !== null) {
            $queryParams['assigned'] = ObjectSerializer::toQueryValue($assigned, null);
        }
        // query params
        if ($unassigned !== null) {
            $queryParams['unassigned'] = ObjectSerializer::toQueryValue($unassigned, null);
        }
        // query params
        if ($task_definition_key !== null) {
            $queryParams['taskDefinitionKey'] = ObjectSerializer::toQueryValue($task_definition_key, null);
        }
        // query params
        if ($task_definition_key_in !== null) {
            $queryParams['taskDefinitionKeyIn'] = ObjectSerializer::toQueryValue($task_definition_key_in, null);
        }
        // query params
        if ($task_definition_key_like !== null) {
            $queryParams['taskDefinitionKeyLike'] = ObjectSerializer::toQueryValue($task_definition_key_like, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($name_not_equal !== null) {
            $queryParams['nameNotEqual'] = ObjectSerializer::toQueryValue($name_not_equal, null);
        }
        // query params
        if ($name_like !== null) {
            $queryParams['nameLike'] = ObjectSerializer::toQueryValue($name_like, null);
        }
        // query params
        if ($name_not_like !== null) {
            $queryParams['nameNotLike'] = ObjectSerializer::toQueryValue($name_not_like, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($description_like !== null) {
            $queryParams['descriptionLike'] = ObjectSerializer::toQueryValue($description_like, null);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority, null);
        }
        // query params
        if ($max_priority !== null) {
            $queryParams['maxPriority'] = ObjectSerializer::toQueryValue($max_priority, null);
        }
        // query params
        if ($min_priority !== null) {
            $queryParams['minPriority'] = ObjectSerializer::toQueryValue($min_priority, null);
        }
        // query params
        if ($due_date !== null) {
            $queryParams['dueDate'] = ObjectSerializer::toQueryValue($due_date, null);
        }
        // query params
        if ($due_date_expression !== null) {
            $queryParams['dueDateExpression'] = ObjectSerializer::toQueryValue($due_date_expression, null);
        }
        // query params
        if ($due_after !== null) {
            $queryParams['dueAfter'] = ObjectSerializer::toQueryValue($due_after, null);
        }
        // query params
        if ($due_after_expression !== null) {
            $queryParams['dueAfterExpression'] = ObjectSerializer::toQueryValue($due_after_expression, null);
        }
        // query params
        if ($due_before !== null) {
            $queryParams['dueBefore'] = ObjectSerializer::toQueryValue($due_before, null);
        }
        // query params
        if ($due_before_expression !== null) {
            $queryParams['dueBeforeExpression'] = ObjectSerializer::toQueryValue($due_before_expression, null);
        }
        // query params
        if ($without_due_date !== null) {
            $queryParams['withoutDueDate'] = ObjectSerializer::toQueryValue($without_due_date, null);
        }
        // query params
        if ($follow_up_date !== null) {
            $queryParams['followUpDate'] = ObjectSerializer::toQueryValue($follow_up_date, null);
        }
        // query params
        if ($follow_up_date_expression !== null) {
            $queryParams['followUpDateExpression'] = ObjectSerializer::toQueryValue($follow_up_date_expression, null);
        }
        // query params
        if ($follow_up_after !== null) {
            $queryParams['followUpAfter'] = ObjectSerializer::toQueryValue($follow_up_after, null);
        }
        // query params
        if ($follow_up_after_expression !== null) {
            $queryParams['followUpAfterExpression'] = ObjectSerializer::toQueryValue($follow_up_after_expression, null);
        }
        // query params
        if ($follow_up_before !== null) {
            $queryParams['followUpBefore'] = ObjectSerializer::toQueryValue($follow_up_before, null);
        }
        // query params
        if ($follow_up_before_expression !== null) {
            $queryParams['followUpBeforeExpression'] = ObjectSerializer::toQueryValue($follow_up_before_expression, null);
        }
        // query params
        if ($follow_up_before_or_not_existent !== null) {
            $queryParams['followUpBeforeOrNotExistent'] = ObjectSerializer::toQueryValue($follow_up_before_or_not_existent, null);
        }
        // query params
        if ($follow_up_before_or_not_existent_expression !== null) {
            $queryParams['followUpBeforeOrNotExistentExpression'] = ObjectSerializer::toQueryValue($follow_up_before_or_not_existent_expression, null);
        }
        // query params
        if ($created_on !== null) {
            $queryParams['createdOn'] = ObjectSerializer::toQueryValue($created_on, null);
        }
        // query params
        if ($created_on_expression !== null) {
            $queryParams['createdOnExpression'] = ObjectSerializer::toQueryValue($created_on_expression, null);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after, null);
        }
        // query params
        if ($created_after_expression !== null) {
            $queryParams['createdAfterExpression'] = ObjectSerializer::toQueryValue($created_after_expression, null);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before, null);
        }
        // query params
        if ($created_before_expression !== null) {
            $queryParams['createdBeforeExpression'] = ObjectSerializer::toQueryValue($created_before_expression, null);
        }
        // query params
        if ($updated_after !== null) {
            $queryParams['updatedAfter'] = ObjectSerializer::toQueryValue($updated_after, null);
        }
        // query params
        if ($updated_after_expression !== null) {
            $queryParams['updatedAfterExpression'] = ObjectSerializer::toQueryValue($updated_after_expression, null);
        }
        // query params
        if ($delegation_state !== null) {
            $queryParams['delegationState'] = ObjectSerializer::toQueryValue($delegation_state, null);
        }
        // query params
        if ($candidate_groups !== null) {
            $queryParams['candidateGroups'] = ObjectSerializer::toQueryValue($candidate_groups, null);
        }
        // query params
        if ($candidate_groups_expression !== null) {
            $queryParams['candidateGroupsExpression'] = ObjectSerializer::toQueryValue($candidate_groups_expression, null);
        }
        // query params
        if ($with_candidate_groups !== null) {
            $queryParams['withCandidateGroups'] = ObjectSerializer::toQueryValue($with_candidate_groups, null);
        }
        // query params
        if ($without_candidate_groups !== null) {
            $queryParams['withoutCandidateGroups'] = ObjectSerializer::toQueryValue($without_candidate_groups, null);
        }
        // query params
        if ($with_candidate_users !== null) {
            $queryParams['withCandidateUsers'] = ObjectSerializer::toQueryValue($with_candidate_users, null);
        }
        // query params
        if ($without_candidate_users !== null) {
            $queryParams['withoutCandidateUsers'] = ObjectSerializer::toQueryValue($without_candidate_users, null);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active, null);
        }
        // query params
        if ($suspended !== null) {
            $queryParams['suspended'] = ObjectSerializer::toQueryValue($suspended, null);
        }
        // query params
        if ($task_variables !== null) {
            $queryParams['taskVariables'] = ObjectSerializer::toQueryValue($task_variables, null);
        }
        // query params
        if ($process_variables !== null) {
            $queryParams['processVariables'] = ObjectSerializer::toQueryValue($process_variables, null);
        }
        // query params
        if ($case_instance_variables !== null) {
            $queryParams['caseInstanceVariables'] = ObjectSerializer::toQueryValue($case_instance_variables, null);
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            $queryParams['variableNamesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_names_ignore_case, null);
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            $queryParams['variableValuesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_values_ignore_case, null);
        }
        // query params
        if ($parent_task_id !== null) {
            $queryParams['parentTaskId'] = ObjectSerializer::toQueryValue($parent_task_id, null);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sortBy'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order, null);
        }
        // query params
        if ($first_result !== null) {
            $queryParams['firstResult'] = ObjectSerializer::toQueryValue($first_result, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTasksCount
     *
     * Get List Count
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CountResultDto
     */
    public function getTasksCount($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null)
    {
        list($response) = $this->getTasksCountWithHttpInfo($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id);
        return $response;
    }

    /**
     * Operation getTasksCountWithHttpInfo
     *
     * Get List Count
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CountResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTasksCountWithHttpInfo($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null)
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->getTasksCountRequest($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTasksCountAsync
     *
     * Get List Count
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksCountAsync($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null)
    {
        return $this->getTasksCountAsyncWithHttpInfo($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTasksCountAsyncWithHttpInfo
     *
     * Get List Count
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksCountAsyncWithHttpInfo($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null)
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->getTasksCountRequest($task_id, $task_id_in, $process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $assignee_not_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $without_due_date, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $updated_after, $updated_after_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTasksCount'
     *
     * @param  string $task_id Restrict to task with the given id. (optional)
     * @param  string $task_id_in Restrict to tasks with any of the given ids. (optional)
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $assignee_not_in Only include tasks which are not assigned to one of the passed and comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  bool $without_due_date Only include tasks which have no due date. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $updated_after Restrict to tasks that were updated after the given date. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. By [default](https://docs.camunda.org/manual/7.21/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $updated_after_expression Restrict to tasks that were updated after the date described by the given expression. Every action that fires  a [task update event](https://docs.camunda.org/manual/7.21/user-guide/process-engine/delegation-code/#task-listener-event-lifecycle) is considered as updating the task. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.21/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;; &#x60;notLike&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTasksCountRequest($task_id = null, $task_id_in = null, $process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = 'false', $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $assignee_not_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = 'false', $involved_user = null, $involved_user_expression = null, $assigned = 'false', $unassigned = 'false', $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $without_due_date = 'false', $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $updated_after = null, $updated_after_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = 'false', $without_candidate_groups = 'false', $with_candidate_users = 'false', $without_candidate_users = 'false', $active = 'false', $suspended = 'false', $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = 'false', $variable_values_ignore_case = 'false', $parent_task_id = null)
    {

        $resourcePath = '/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($task_id !== null) {
            $queryParams['taskId'] = ObjectSerializer::toQueryValue($task_id, null);
        }
        // query params
        if ($task_id_in !== null) {
            $queryParams['taskIdIn'] = ObjectSerializer::toQueryValue($task_id_in, null);
        }
        // query params
        if ($process_instance_id !== null) {
            $queryParams['processInstanceId'] = ObjectSerializer::toQueryValue($process_instance_id, null);
        }
        // query params
        if ($process_instance_id_in !== null) {
            $queryParams['processInstanceIdIn'] = ObjectSerializer::toQueryValue($process_instance_id_in, null);
        }
        // query params
        if ($process_instance_business_key !== null) {
            $queryParams['processInstanceBusinessKey'] = ObjectSerializer::toQueryValue($process_instance_business_key, null);
        }
        // query params
        if ($process_instance_business_key_expression !== null) {
            $queryParams['processInstanceBusinessKeyExpression'] = ObjectSerializer::toQueryValue($process_instance_business_key_expression, null);
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            $queryParams['processInstanceBusinessKeyIn'] = ObjectSerializer::toQueryValue($process_instance_business_key_in, null);
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            $queryParams['processInstanceBusinessKeyLike'] = ObjectSerializer::toQueryValue($process_instance_business_key_like, null);
        }
        // query params
        if ($process_instance_business_key_like_expression !== null) {
            $queryParams['processInstanceBusinessKeyLikeExpression'] = ObjectSerializer::toQueryValue($process_instance_business_key_like_expression, null);
        }
        // query params
        if ($process_definition_id !== null) {
            $queryParams['processDefinitionId'] = ObjectSerializer::toQueryValue($process_definition_id, null);
        }
        // query params
        if ($process_definition_key !== null) {
            $queryParams['processDefinitionKey'] = ObjectSerializer::toQueryValue($process_definition_key, null);
        }
        // query params
        if ($process_definition_key_in !== null) {
            $queryParams['processDefinitionKeyIn'] = ObjectSerializer::toQueryValue($process_definition_key_in, null);
        }
        // query params
        if ($process_definition_name !== null) {
            $queryParams['processDefinitionName'] = ObjectSerializer::toQueryValue($process_definition_name, null);
        }
        // query params
        if ($process_definition_name_like !== null) {
            $queryParams['processDefinitionNameLike'] = ObjectSerializer::toQueryValue($process_definition_name_like, null);
        }
        // query params
        if ($execution_id !== null) {
            $queryParams['executionId'] = ObjectSerializer::toQueryValue($execution_id, null);
        }
        // query params
        if ($case_instance_id !== null) {
            $queryParams['caseInstanceId'] = ObjectSerializer::toQueryValue($case_instance_id, null);
        }
        // query params
        if ($case_instance_business_key !== null) {
            $queryParams['caseInstanceBusinessKey'] = ObjectSerializer::toQueryValue($case_instance_business_key, null);
        }
        // query params
        if ($case_instance_business_key_like !== null) {
            $queryParams['caseInstanceBusinessKeyLike'] = ObjectSerializer::toQueryValue($case_instance_business_key_like, null);
        }
        // query params
        if ($case_definition_id !== null) {
            $queryParams['caseDefinitionId'] = ObjectSerializer::toQueryValue($case_definition_id, null);
        }
        // query params
        if ($case_definition_key !== null) {
            $queryParams['caseDefinitionKey'] = ObjectSerializer::toQueryValue($case_definition_key, null);
        }
        // query params
        if ($case_definition_name !== null) {
            $queryParams['caseDefinitionName'] = ObjectSerializer::toQueryValue($case_definition_name, null);
        }
        // query params
        if ($case_definition_name_like !== null) {
            $queryParams['caseDefinitionNameLike'] = ObjectSerializer::toQueryValue($case_definition_name_like, null);
        }
        // query params
        if ($case_execution_id !== null) {
            $queryParams['caseExecutionId'] = ObjectSerializer::toQueryValue($case_execution_id, null);
        }
        // query params
        if ($activity_instance_id_in !== null) {
            $queryParams['activityInstanceIdIn'] = ObjectSerializer::toQueryValue($activity_instance_id_in, null);
        }
        // query params
        if ($tenant_id_in !== null) {
            $queryParams['tenantIdIn'] = ObjectSerializer::toQueryValue($tenant_id_in, null);
        }
        // query params
        if ($without_tenant_id !== null) {
            $queryParams['withoutTenantId'] = ObjectSerializer::toQueryValue($without_tenant_id, null);
        }
        // query params
        if ($assignee !== null) {
            $queryParams['assignee'] = ObjectSerializer::toQueryValue($assignee, null);
        }
        // query params
        if ($assignee_expression !== null) {
            $queryParams['assigneeExpression'] = ObjectSerializer::toQueryValue($assignee_expression, null);
        }
        // query params
        if ($assignee_like !== null) {
            $queryParams['assigneeLike'] = ObjectSerializer::toQueryValue($assignee_like, null);
        }
        // query params
        if ($assignee_like_expression !== null) {
            $queryParams['assigneeLikeExpression'] = ObjectSerializer::toQueryValue($assignee_like_expression, null);
        }
        // query params
        if ($assignee_in !== null) {
            $queryParams['assigneeIn'] = ObjectSerializer::toQueryValue($assignee_in, null);
        }
        // query params
        if ($assignee_not_in !== null) {
            $queryParams['assigneeNotIn'] = ObjectSerializer::toQueryValue($assignee_not_in, null);
        }
        // query params
        if ($owner !== null) {
            $queryParams['owner'] = ObjectSerializer::toQueryValue($owner, null);
        }
        // query params
        if ($owner_expression !== null) {
            $queryParams['ownerExpression'] = ObjectSerializer::toQueryValue($owner_expression, null);
        }
        // query params
        if ($candidate_group !== null) {
            $queryParams['candidateGroup'] = ObjectSerializer::toQueryValue($candidate_group, null);
        }
        // query params
        if ($candidate_group_expression !== null) {
            $queryParams['candidateGroupExpression'] = ObjectSerializer::toQueryValue($candidate_group_expression, null);
        }
        // query params
        if ($candidate_user !== null) {
            $queryParams['candidateUser'] = ObjectSerializer::toQueryValue($candidate_user, null);
        }
        // query params
        if ($candidate_user_expression !== null) {
            $queryParams['candidateUserExpression'] = ObjectSerializer::toQueryValue($candidate_user_expression, null);
        }
        // query params
        if ($include_assigned_tasks !== null) {
            $queryParams['includeAssignedTasks'] = ObjectSerializer::toQueryValue($include_assigned_tasks, null);
        }
        // query params
        if ($involved_user !== null) {
            $queryParams['involvedUser'] = ObjectSerializer::toQueryValue($involved_user, null);
        }
        // query params
        if ($involved_user_expression !== null) {
            $queryParams['involvedUserExpression'] = ObjectSerializer::toQueryValue($involved_user_expression, null);
        }
        // query params
        if ($assigned !== null) {
            $queryParams['assigned'] = ObjectSerializer::toQueryValue($assigned, null);
        }
        // query params
        if ($unassigned !== null) {
            $queryParams['unassigned'] = ObjectSerializer::toQueryValue($unassigned, null);
        }
        // query params
        if ($task_definition_key !== null) {
            $queryParams['taskDefinitionKey'] = ObjectSerializer::toQueryValue($task_definition_key, null);
        }
        // query params
        if ($task_definition_key_in !== null) {
            $queryParams['taskDefinitionKeyIn'] = ObjectSerializer::toQueryValue($task_definition_key_in, null);
        }
        // query params
        if ($task_definition_key_like !== null) {
            $queryParams['taskDefinitionKeyLike'] = ObjectSerializer::toQueryValue($task_definition_key_like, null);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name, null);
        }
        // query params
        if ($name_not_equal !== null) {
            $queryParams['nameNotEqual'] = ObjectSerializer::toQueryValue($name_not_equal, null);
        }
        // query params
        if ($name_like !== null) {
            $queryParams['nameLike'] = ObjectSerializer::toQueryValue($name_like, null);
        }
        // query params
        if ($name_not_like !== null) {
            $queryParams['nameNotLike'] = ObjectSerializer::toQueryValue($name_not_like, null);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description, null);
        }
        // query params
        if ($description_like !== null) {
            $queryParams['descriptionLike'] = ObjectSerializer::toQueryValue($description_like, null);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority, null);
        }
        // query params
        if ($max_priority !== null) {
            $queryParams['maxPriority'] = ObjectSerializer::toQueryValue($max_priority, null);
        }
        // query params
        if ($min_priority !== null) {
            $queryParams['minPriority'] = ObjectSerializer::toQueryValue($min_priority, null);
        }
        // query params
        if ($due_date !== null) {
            $queryParams['dueDate'] = ObjectSerializer::toQueryValue($due_date, null);
        }
        // query params
        if ($due_date_expression !== null) {
            $queryParams['dueDateExpression'] = ObjectSerializer::toQueryValue($due_date_expression, null);
        }
        // query params
        if ($due_after !== null) {
            $queryParams['dueAfter'] = ObjectSerializer::toQueryValue($due_after, null);
        }
        // query params
        if ($due_after_expression !== null) {
            $queryParams['dueAfterExpression'] = ObjectSerializer::toQueryValue($due_after_expression, null);
        }
        // query params
        if ($due_before !== null) {
            $queryParams['dueBefore'] = ObjectSerializer::toQueryValue($due_before, null);
        }
        // query params
        if ($due_before_expression !== null) {
            $queryParams['dueBeforeExpression'] = ObjectSerializer::toQueryValue($due_before_expression, null);
        }
        // query params
        if ($without_due_date !== null) {
            $queryParams['withoutDueDate'] = ObjectSerializer::toQueryValue($without_due_date, null);
        }
        // query params
        if ($follow_up_date !== null) {
            $queryParams['followUpDate'] = ObjectSerializer::toQueryValue($follow_up_date, null);
        }
        // query params
        if ($follow_up_date_expression !== null) {
            $queryParams['followUpDateExpression'] = ObjectSerializer::toQueryValue($follow_up_date_expression, null);
        }
        // query params
        if ($follow_up_after !== null) {
            $queryParams['followUpAfter'] = ObjectSerializer::toQueryValue($follow_up_after, null);
        }
        // query params
        if ($follow_up_after_expression !== null) {
            $queryParams['followUpAfterExpression'] = ObjectSerializer::toQueryValue($follow_up_after_expression, null);
        }
        // query params
        if ($follow_up_before !== null) {
            $queryParams['followUpBefore'] = ObjectSerializer::toQueryValue($follow_up_before, null);
        }
        // query params
        if ($follow_up_before_expression !== null) {
            $queryParams['followUpBeforeExpression'] = ObjectSerializer::toQueryValue($follow_up_before_expression, null);
        }
        // query params
        if ($follow_up_before_or_not_existent !== null) {
            $queryParams['followUpBeforeOrNotExistent'] = ObjectSerializer::toQueryValue($follow_up_before_or_not_existent, null);
        }
        // query params
        if ($follow_up_before_or_not_existent_expression !== null) {
            $queryParams['followUpBeforeOrNotExistentExpression'] = ObjectSerializer::toQueryValue($follow_up_before_or_not_existent_expression, null);
        }
        // query params
        if ($created_on !== null) {
            $queryParams['createdOn'] = ObjectSerializer::toQueryValue($created_on, null);
        }
        // query params
        if ($created_on_expression !== null) {
            $queryParams['createdOnExpression'] = ObjectSerializer::toQueryValue($created_on_expression, null);
        }
        // query params
        if ($created_after !== null) {
            $queryParams['createdAfter'] = ObjectSerializer::toQueryValue($created_after, null);
        }
        // query params
        if ($created_after_expression !== null) {
            $queryParams['createdAfterExpression'] = ObjectSerializer::toQueryValue($created_after_expression, null);
        }
        // query params
        if ($created_before !== null) {
            $queryParams['createdBefore'] = ObjectSerializer::toQueryValue($created_before, null);
        }
        // query params
        if ($created_before_expression !== null) {
            $queryParams['createdBeforeExpression'] = ObjectSerializer::toQueryValue($created_before_expression, null);
        }
        // query params
        if ($updated_after !== null) {
            $queryParams['updatedAfter'] = ObjectSerializer::toQueryValue($updated_after, null);
        }
        // query params
        if ($updated_after_expression !== null) {
            $queryParams['updatedAfterExpression'] = ObjectSerializer::toQueryValue($updated_after_expression, null);
        }
        // query params
        if ($delegation_state !== null) {
            $queryParams['delegationState'] = ObjectSerializer::toQueryValue($delegation_state, null);
        }
        // query params
        if ($candidate_groups !== null) {
            $queryParams['candidateGroups'] = ObjectSerializer::toQueryValue($candidate_groups, null);
        }
        // query params
        if ($candidate_groups_expression !== null) {
            $queryParams['candidateGroupsExpression'] = ObjectSerializer::toQueryValue($candidate_groups_expression, null);
        }
        // query params
        if ($with_candidate_groups !== null) {
            $queryParams['withCandidateGroups'] = ObjectSerializer::toQueryValue($with_candidate_groups, null);
        }
        // query params
        if ($without_candidate_groups !== null) {
            $queryParams['withoutCandidateGroups'] = ObjectSerializer::toQueryValue($without_candidate_groups, null);
        }
        // query params
        if ($with_candidate_users !== null) {
            $queryParams['withCandidateUsers'] = ObjectSerializer::toQueryValue($with_candidate_users, null);
        }
        // query params
        if ($without_candidate_users !== null) {
            $queryParams['withoutCandidateUsers'] = ObjectSerializer::toQueryValue($without_candidate_users, null);
        }
        // query params
        if ($active !== null) {
            $queryParams['active'] = ObjectSerializer::toQueryValue($active, null);
        }
        // query params
        if ($suspended !== null) {
            $queryParams['suspended'] = ObjectSerializer::toQueryValue($suspended, null);
        }
        // query params
        if ($task_variables !== null) {
            $queryParams['taskVariables'] = ObjectSerializer::toQueryValue($task_variables, null);
        }
        // query params
        if ($process_variables !== null) {
            $queryParams['processVariables'] = ObjectSerializer::toQueryValue($process_variables, null);
        }
        // query params
        if ($case_instance_variables !== null) {
            $queryParams['caseInstanceVariables'] = ObjectSerializer::toQueryValue($case_instance_variables, null);
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            $queryParams['variableNamesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_names_ignore_case, null);
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            $queryParams['variableValuesIgnoreCase'] = ObjectSerializer::toQueryValue($variable_values_ignore_case, null);
        }
        // query params
        if ($parent_task_id !== null) {
            $queryParams['parentTaskId'] = ObjectSerializer::toQueryValue($parent_task_id, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation handleBpmnError
     *
     * Handle BPMN Error
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \Swagger\Client\Model\TaskBpmnErrorDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function handleBpmnError($id, $body = null)
    {
        $this->handleBpmnErrorWithHttpInfo($id, $body);
    }

    /**
     * Operation handleBpmnErrorWithHttpInfo
     *
     * Handle BPMN Error
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \Swagger\Client\Model\TaskBpmnErrorDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function handleBpmnErrorWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->handleBpmnErrorRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation handleBpmnErrorAsync
     *
     * Handle BPMN Error
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \Swagger\Client\Model\TaskBpmnErrorDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleBpmnErrorAsync($id, $body = null)
    {
        return $this->handleBpmnErrorAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation handleBpmnErrorAsyncWithHttpInfo
     *
     * Handle BPMN Error
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \Swagger\Client\Model\TaskBpmnErrorDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleBpmnErrorAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->handleBpmnErrorRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'handleBpmnError'
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \Swagger\Client\Model\TaskBpmnErrorDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function handleBpmnErrorRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling handleBpmnError'
            );
        }

        $resourcePath = '/task/{id}/bpmnError';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation handleEscalation
     *
     * Handle BPMN Escalation
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \Swagger\Client\Model\TaskEscalationDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function handleEscalation($id, $body = null)
    {
        $this->handleEscalationWithHttpInfo($id, $body);
    }

    /**
     * Operation handleEscalationWithHttpInfo
     *
     * Handle BPMN Escalation
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \Swagger\Client\Model\TaskEscalationDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function handleEscalationWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->handleEscalationRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation handleEscalationAsync
     *
     * Handle BPMN Escalation
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \Swagger\Client\Model\TaskEscalationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleEscalationAsync($id, $body = null)
    {
        return $this->handleEscalationAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation handleEscalationAsyncWithHttpInfo
     *
     * Handle BPMN Escalation
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \Swagger\Client\Model\TaskEscalationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleEscalationAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->handleEscalationRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'handleEscalation'
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \Swagger\Client\Model\TaskEscalationDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function handleEscalationRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling handleEscalation'
            );
        }

        $resourcePath = '/task/{id}/bpmnEscalation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTasks
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\TaskDto[]
     */
    public function queryTasks($body = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->queryTasksWithHttpInfo($body, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation queryTasksWithHttpInfo
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\TaskDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTasksWithHttpInfo($body = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Swagger\Client\Model\TaskDto[]';
        $request = $this->queryTasksRequest($body, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\TaskDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTasksAsync
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksAsync($body = null, $first_result = null, $max_results = null)
    {
        return $this->queryTasksAsyncWithHttpInfo($body, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTasksAsyncWithHttpInfo
     *
     * Get List (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksAsyncWithHttpInfo($body = null, $first_result = null, $max_results = null)
    {
        $returnType = '\Swagger\Client\Model\TaskDto[]';
        $request = $this->queryTasksRequest($body, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTasks'
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTasksRequest($body = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($first_result !== null) {
            $queryParams['firstResult'] = ObjectSerializer::toQueryValue($first_result, null);
        }
        // query params
        if ($max_results !== null) {
            $queryParams['maxResults'] = ObjectSerializer::toQueryValue($max_results, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTasksCount
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CountResultDto
     */
    public function queryTasksCount($body = null)
    {
        list($response) = $this->queryTasksCountWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation queryTasksCountWithHttpInfo
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CountResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTasksCountWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->queryTasksCountRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTasksCountAsync
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksCountAsync($body = null)
    {
        return $this->queryTasksCountAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTasksCountAsyncWithHttpInfo
     *
     * Get List Count (POST)
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksCountAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Swagger\Client\Model\CountResultDto';
        $request = $this->queryTasksCountRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTasksCount'
     *
     * @param  \Swagger\Client\Model\TaskQueryDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTasksCountRequest($body = null)
    {

        $resourcePath = '/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resolve
     *
     * Resolve
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resolve($id, $body = null)
    {
        $this->resolveWithHttpInfo($id, $body);
    }

    /**
     * Operation resolveWithHttpInfo
     *
     * Resolve
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resolveWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->resolveRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resolveAsync
     *
     * Resolve
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resolveAsync($id, $body = null)
    {
        return $this->resolveAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resolveAsyncWithHttpInfo
     *
     * Resolve
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resolveAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->resolveRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resolve'
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resolveRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling resolve'
            );
        }

        $resourcePath = '/task/{id}/resolve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setAssignee
     *
     * Set Assignee
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setAssignee($id, $body = null)
    {
        $this->setAssigneeWithHttpInfo($id, $body);
    }

    /**
     * Operation setAssigneeWithHttpInfo
     *
     * Set Assignee
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setAssigneeWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->setAssigneeRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setAssigneeAsync
     *
     * Set Assignee
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setAssigneeAsync($id, $body = null)
    {
        return $this->setAssigneeAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setAssigneeAsyncWithHttpInfo
     *
     * Set Assignee
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setAssigneeAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->setAssigneeRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setAssignee'
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \Swagger\Client\Model\UserIdDto $body Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setAssigneeRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setAssignee'
            );
        }

        $resourcePath = '/task/{id}/assignee';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submit
     *
     * Submit Form
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\Swagger\Client\Model\VariableValueDto]
     */
    public function submit($id, $body = null)
    {
        list($response) = $this->submitWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation submitWithHttpInfo
     *
     * Submit Form
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\Swagger\Client\Model\VariableValueDto], HTTP status code, HTTP response headers (array of strings)
     */
    public function submitWithHttpInfo($id, $body = null)
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->submitRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\Swagger\Client\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitAsync
     *
     * Submit Form
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitAsync($id, $body = null)
    {
        return $this->submitAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitAsyncWithHttpInfo
     *
     * Submit Form
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = 'map[string,\Swagger\Client\Model\VariableValueDto]';
        $request = $this->submitRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submit'
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \Swagger\Client\Model\CompleteTaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function submitRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling submit'
            );
        }

        $resourcePath = '/task/{id}/submit-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unclaim
     *
     * Unclaim
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unclaim($id)
    {
        $this->unclaimWithHttpInfo($id);
    }

    /**
     * Operation unclaimWithHttpInfo
     *
     * Unclaim
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unclaimWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->unclaimRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unclaimAsync
     *
     * Unclaim
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unclaimAsync($id)
    {
        return $this->unclaimAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unclaimAsyncWithHttpInfo
     *
     * Unclaim
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unclaimAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->unclaimRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unclaim'
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function unclaimRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling unclaim'
            );
        }

        $resourcePath = '/task/{id}/unclaim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTask
     *
     * Update
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \Swagger\Client\Model\TaskDto $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateTask($id, $body = null)
    {
        $this->updateTaskWithHttpInfo($id, $body);
    }

    /**
     * Operation updateTaskWithHttpInfo
     *
     * Update
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaskWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateTaskRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTaskAsync
     *
     * Update
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsync($id, $body = null)
    {
        return $this->updateTaskAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaskAsyncWithHttpInfo
     *
     * Update
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '';
        $request = $this->updateTaskRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTask'
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \Swagger\Client\Model\TaskDto $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateTaskRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateTask'
            );
        }

        $resourcePath = '/task/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if ($this->config->getUsername() !== null || $this->config->getPassword() !== null) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
